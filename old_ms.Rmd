---
title: "Untitled"
author: "Lucas A. Nell"
date: "4/4/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





## Performance

Performance was tested on a 2013 MacBook Pro running macOS High Sierra with a 
2.6GHz Intel Core i5 processor and 8 GB RAM.
I compared the performance of `jackalope` functions to those in other packages based on 
the time and maximum RAM required for each to perform its task.
RAM usage is presented as the maximum usage during an R session where the only
actions taken were to load the necessary package and run the function.
Thus overhead associated with loading a package is included.
For functions in packages outside `jackalope`, I use the R convention of displaying them as
the package name, two colons, then the function name (e.g., `Package::Function`).




### Reference-genome creating, reading, and digesting

For performance comparisons in creating, reading, and digesting reference genomes, 
I used the R packages `SimRAD`
<!-- ` r keep_title("SimRAD", -->
<!-- "{SimRAD:} Simulations to Predict the Number of {RAD} and {GBS} Loci")` -->
and `ShortRead`
<!-- ` r citep(citation("ShortRead"))`. -->
.
`SimRAD` is designed to assist in research design for RADseq studies, and 
`ShortRead` performs data input in the Bioconductor system
`r citep("10.1038/nmeth.3252")`.

For the performance of creating a reference genome, I compared `create_genome` 
to `SimRAD::sim.DNAseq` in creating one 100 Mbp chromosome.
Although `create_genome` can use multiple cores, I only use one for the comparison test
because `SimRAD::sim.DNAseq` can only use one and because multithreading in 
`create_genome` is done across multiple sequences.
I also report on the performance of `create_genome` in creating a 1 Gbp genome split 
among eight chromosomes.


To test reference-genome read and digestion performance, I used the 
threespine stickleback (*Gasterosteus aculeatus*) genome 
`r gsub("\\[", "\\[438 Mbp; ", citep("10.1093/jhered/esx058"))`.
For reading, I compared `read_fasta` (with and without a fasta index file) 
to `ShortRead::readFasta`, separately for uncompressed and gzipped files.
I compared digestion between `digest_genome` and `SimRAD::insilico.digest` using the restriction enzyme *ApeKI* (1.3 million cut sites).


```{r SimRAD-comp-table}
SimRAD_table <- readr::read_csv('data/SimRAD_tests.csv', col_types = 'cccdi', 
                                comment = '#')
SimRAD_table$Task[is.na(SimRAD_table$Task)] <- ""
SimRAD_table <- SimRAD_table %>% 
    mutate_at(vars(Package, Function), 
              function(x) sprintf("\\texttt{%s}", gsub("`", "", x))) %>% 
    mutate(Function = Function %>% 
               str_replace_all("†\\}", "\\}$^\\{\\\\dagger\\}$") %>% 
               str_replace_all("‡\\}", "\\}$^\\{\\\\ddagger\\}$") %>% 
               str_replace_all("\\_", "\\\\_"))

pretty_df(SimRAD_table, 
          caption = paste("Performance of \\texttt{jackalope}, \\texttt{SimRAD}, and",
                          "\\texttt{ShortRead} package functions for creating,",
                          "reading, and digesting reference genomes.",
                          "† indicates a run using 4 cores.",
                          "‡ indicates a run using a FASTA index file."))
```



Table \@ref(tab:SimRAD-comp-table) shows that `jackalope` outperforms `SimRAD` across
all functions for both elapsed time and RAM used.
`jackalope` outperformed `ShortRead` in reading FASTA files when an index file was 
used in the former, but `jackalope` became slower without an index file.
RAM usage for `ShortRead::readFasta` was higher than for `read_fasta` largely
due to the overhead associated with loading required packages.
Before running any functions, loading `SimRAD` or `ShortRead` increased RAM usage by
~`r 380-55` MB, while `jackalope` only increased it by ~`r 80-55` MB.


### Molecular evolution simulation

Here I will compare my method of simulating variants with those from package `phylosim`.
However, I am not finished coding this portion of the package.


## Example usage

### Choose a restriction enzyme for RADseq

Many common restriction enzymes are already programmed into the `digest` command, so 
comparing different digestions is simple.
The example below digests the stickleback genome using *ApeKI* and *AscI*
and plots the resulting fragment sizes (Figure \@ref(fig:choose-enzyme-run)).

```{r choose-enzyme-display, echo = TRUE, eval = FALSE}
genome <- read_fasta('stickleback_genome.fa')
dig_ApeKI <- digest(genome, 'ApeKI', n_cores = 4)
dig_AscI <- digest(genome, 'AscI', n_cores = 4)
plot_digest(list(dig_ApeKI, dig_AscI), genome)
```

```{r choose-enzyme-caption, include=FALSE}
ce_cap <- paste("Example digestion of the threespine stickleback genome with two",
                "restriction enzymes. X-axes are on the log scale.")
```

```{r choose-enzyme-run, fig.height=3.5, fig.width=6, fig.cap=ce_cap, cache=FALSE}
genome <- read_fasta('../safepug/gfiles/Gac_genome.fa.gz',
                     '../safepug/gfiles/Gac_genome.fa.fai.gz')
apeki <- safepug::binding_sites[['ApeKI']]
apeki <- sapply(c(1,3), function(i) paste(apeki[i:(i+1)], collapse = ''))
asci <- paste0(safepug::binding_sites[['AscI']], collapse = '')
dig_ApeKI <- digest_ref(genome, apeki, c(1,1), n_cores = 3)
dig_AscI <- digest_ref(genome, asci, 2, n_cores = 3)
ref_names <- sapply(0:(get_ref_n_scaff(genome)-1), get_ref_name, ref_ = genome)
names(dig_ApeKI) <- ref_names
names(dig_AscI) <- ref_names
dig_ApeKI_df <- lapply(1:length(dig_ApeKI), 
                       function(i) data_frame(
                           seq = names(dig_ApeKI)[i], 
                           enzyme = 'ApeKI',
                           length = diff(c(0, dig_ApeKI[[i]], 
                                           get_ref_seq_size(genome, i-1))))) %>% 
    bind_rows
dig_AscI_df <- lapply(1:length(dig_AscI), 
                      function(i) data_frame(
                          seq = names(dig_AscI)[i], 
                          enzyme = 'AscI',
                          length = diff(c(0, dig_AscI[[i]], 
                                          get_ref_seq_size(genome, i-1))))) %>% 
    bind_rows

dig_df <- bind_rows(dig_ApeKI_df, dig_AscI_df) %>% 
    filter(!seq %in% c("chrM", "chrUn")) %>% 
    mutate(seq = factor(seq, levels = c("chrI", "chrII", "chrIII", "chrIV", 
                                        "chrV", "chrVI", "chrVII", "chrVIII", "chrIX",
                                        "chrX", "chrXI", "chrXII", "chrXIII", "chrXIV",
                                        "chrXV", "chrXVI", "chrXVII", "chrXVIII", 
                                        "chrXIX", "chrXX", "chrXXI")),
                                        # "chrM", "chrUn")),
           enzyme = factor(enzyme, levels = c('ApeKI', 'AscI')))
# source(".Rprofile")
dig_df %>% 
    ggplot(aes(length, ..density.., color = enzyme)) +
    geom_freqpoly(bins = 25) +
    theme(legend.position = 'top', 
          legend.text = element_text(face = 'italic', margin = margin(0,0,0,0)),
          legend.title = element_blank()) +
    facet_wrap(~ seq, nrow = 3) +
    scale_x_log10('Fragment size', breaks = 10^(c(3, 6)), 
                  labels = trans_format('log10',math_format(10^.x))) +
    scale_y_continuous('Density', breaks = c(0, 0.5, 1)) +
    scale_color_manual(values = c('dodgerblue', 'firebrick')) +
    guides(color = guide_legend(keywidth = 1.5, keyheight = 0.5))
```


### Test variant-calling effectiveness in WGS versus RADseq

This portion is not yet coded.

### Compute the power of various depths of coverage in WGS

This portion is not yet coded.

## Conclusion

`jackalope` outperforms current programs while providing a more flexible platform.
This package should inform research design for projects employing HTS,
particularly those in population genomics.
Output from `jackalope` will help develop more specific sequencing goals 
in funding applications and estimate the power of a given sequencing design.
Furthermore, `jackalope` can be used to test bioinformatic pipelines under assumptions of
much more complex demographic histories than current HTS simulation 
platforms allow.



# References

```{r biblio, message = FALSE, eval = TRUE}
write.bibtex(file="references.bib")
```


