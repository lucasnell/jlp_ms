---
title: "jackelope: A swift, versatile molecular evolution and sequencing simulator"
bibliography: "references.bib"
csl: "apa.csl"
fontsize: 12pt
geometry: margin=1in,letterpaper
documentclass: article
tables: true
graphics: true
colorlinks: true
mathspec: true
linestretch: 1.5
sectionbreaks: true
sectionnumbering: true
raggedtoc: true
output: 
  pdf_document: 
    fig_caption: yes
    keep_tex: yes
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE, cache = FALSE}
suppressPackageStartupMessages({
    library(knitr)
    library(knitcitations)
    library(tidyverse)
})
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, eval = FALSE, dev = 'quartz_pdf')
knitr::knit_theme$set(knitr::knit_theme$get("acid"))

theme_set(theme_classic() + 
              theme(legend.background = element_blank(),
                    strip.background = element_blank(),
                    plot.margin = margin(0.5, 0.5, 0.5, 0.5)))

cleanbib()
options("citation_format" = "pandoc", knitr.graphics.auto_pdf = TRUE)

old_ref <- function(key, parenth = TRUE) {
    if (parenth) {
        citep(bibtex::read.bib(file = 'old_refs.bib')[key])
    } else {
        citet(bibtex::read.bib(file = 'old_refs.bib')[key])
    }
}
no_auth <- function(key) gsub("@", "-@", key)
old_new <- function(old, new) {
    old_ <- old_ref(old)
    new_ <- citep(new)
    paste(gsub("\\]", "", old_), gsub("\\[", "", new_), sep = "; ")
}
# Sort citations as they'll appear in the in-text citation: by year, then name
sort_cit <- function(citation) {
    split_cit <- {str_split(citation, "; ")[[1]]} %>%
        str_replace_all("\\[|\\]", "")
    years <- split_cit %>%
        str_split("_") %>% 
        map_chr(~ tail(.x, 1))
    names <- split_cit %>% 
        str_split("_") %>% 
        map_chr(~ head(.x, -1) %>% str_c(collapse = "_"))
    output <- split_cit[order(years, names)] %>% 
        str_c(collapse = "; ")
    return(output)
}
prefix <- function(pre, citation) {
    sorted_cit <- sort_cit(citation)
    output <- sprintf(fmt = "[%s %s]", pre, sorted_cit)
    return(output)
}
suffix <- function(citation, suf) {
    sorted_cit <- sort_cit(citation)
    output <- sprintf(fmt = "[%s %s]", sorted_cit, suf)
    return(output)
}
prefix_suffix <- function(pre, citation, suf) {
    sorted_cit <- sort_cit(citation)
    output <- sprintf(fmt = "[%s %s %s]", pre, sorted_cit, suf)
    return(output)
}

# Allows you to specify the title yourself for calls to `citation` inside `citep`
keep_title <- function(pkg_name, set_title = NULL, index = NULL) {
    z <- citation(pkg_name)
    if (!is.null(index)) z <- z[index]
    if (is.null(set_title)) {
        z$title <- sprintf("{%s}", z$title)
    } else {
        z$title <- set_title
    }
    return(citep(z))
}

# Function to print data frames for LaTeX output using booktabs package
pretty_df <- function(df_, caption = NULL, edit_nums = FALSE) {
    edit_nums_fxn <- function(.df){
        .df %>%
            mutate_if(is.numeric,
                      function(x) {
                          x %>% sprintf(fmt = '%.4g') %>%
                              sapply(., parse_scinot)
                      })
    }
    if (edit_nums) {
        if (is(df_, 'list')) {
            df_ <- lapply(df_, edit_nums_fxn)
        } else {
            df_ <- edit_nums_fxn(df_)
        }
    }
    kable_obj <- knitr::kable(df_, format = 'latex', booktabs = TRUE,
                              caption = caption, escape = FALSE)
    kable_str <- unlist(str_split(kable_obj, '\n'))
    kable_str <- kable_str[kable_str != "\\addlinespace"]
    for (i in 1:(length(kable_str)-1)) {
        if (grepl('^ &', kable_str[i]) & !grepl('^ &', kable_str[(i+1)]) &
            !grepl('^\\bottomrule', kable_str[(i+1)])) {
            kable_str[i] <- str_c(kable_str[i], "\n", "\\addlinespace")
        }
    }
    new_kable_str <- str_c(kable_str, collapse = '\n')
    kable_obj[1] <- new_kable_str
    return(kable_obj)
}

# Removes "e+X" or "e-X" (X is a 2-character number like "04" or "22"), converts to
# "2 \times 10^Z" for LaTeX (Z is a normal number like "4" or "-22")
pretty_num <- function(num, sigfigs = 2) {
    
    nstr <- sprintf(fmt = paste0("%.",sigfigs,"g"), num)
    
    if (str_detect(nstr, 'e-0')) {
        nstr <- str_replace(nstr, "e-0", " \\\\times 10^\\{-") %>% str_c("}")
    } else if (str_detect(nstr, 'e-')) {
        nstr <- str_replace(nstr, "e-", " \\\\times 10^\\{-") %>% str_c("}")
    } else if (str_detect(nstr, 'e\\+0')) {
        nstr <- str_replace(nstr, "e\\+0", " \\\\times 10^")
    } else if (str_detect(nstr, 'e\\+')) {
        nstr <- str_replace(nstr, "e\\+", " \\\\times 10^")
    }
    return(nstr)
}
```


## Abstract

High-throughput sequencing (HTS) is central to the study of population genomics.
Choices in sampling design for sequencing projects can include 
sequencing platform, depth of coverage, and number of individuals to sample.
These choices are most often informed by previous work on highly diverged species, 
which ignores species- and population-specific genomic characteristics, demographies, 
and evolutionary histories.
Simulating sequencing based on available genomic data better informs sampling
strategies.
However, most current methods provide only rudimentary ways to simulate population
structure and variation in coverage among sites.
Here I present the R package `jackelope` that efficiently 
(i) reads and simulates reference genomes;
(ii) generates variants using summary statistics, phylogenies, 
Variant Call Format (VCF) files, and coalescent simulations---the latter of which can
include selection, recombination, and demographic fluctuations;
(iii) simulates sequencing error, mapping qualities, multiplexing, and
optical/PCR duplicates;
and
(iv) writes outputs to standard file formats.
`jackelope` can simulate single, paired-end, or mate-pair Illumina reads,
as well as reads from Pacific BioSciences.
Most functions are written in C++ to improve performance, and I employed OpenMP to 
allow for parallel processing.
`jackelope` is available on GitHub
(https://github.com/lucasnell/jackelope).


<!-- The stable version of `jackelope` is available on CRAN -->
<!-- (https://CRAN.R-project.org/package=jackelope), -->
<!-- and the development version is on GitHub -->
<!-- (https://github.com/lucasnell/jackelope). -->



__Keywords\:__ sequencing simulator, population genomics, high-throughput sequencing,
Illumina, Pacific Biosciences, Pool-seq



## Introduction



High-throughput sequencing (HTS) is a cost-effective approach to generate vast amounts
of genomic data and has revolutionized the study of genomes
`r citep("10.1038/nrg2626")`.
Large datasets combined with increased error rates---compared to Sanger sequencing---make
bioinformatic pipelines an important aspect of research using HTS.
Many bioinformatic tools exist, and new programs that are more accurate and
computationally efficient are constantly being developed.
To test these tools against known parameter values, in silico simulation of
genomic data is needed. Although there are many sequence simulators currently available
`r prefix("reviewed in", citep("10.1038/nrg.2016.57"))`,
most have only rudimentary ways to generate population-level data.
Events like population-size changes, selection, or population structure
can drastically change null expectations for sequence data, but including
these possibilities is impossible with most current methods.



<!---

ADD HERE DESCRIPTIONS OF CURRENT TOOLS

-->



In the present paper I introduce `jackelope`, the first available HTS simulator
in the R
`r keep_title("base", "{R:} A Language and Environment for Statistical Computing")`
environment.
Designed for efficient memory use, flexibility, and speed,
`jackelope` combines the functionality of an HTS simulator with that of a
molecular phylogenetics simulator.
Genomes can be derived from FASTA files or simulated in silico.
`jackelope` can create variants from the reference genome based on basic 
population-genomic summary statistics, phylogenies, Variant Call Format (VCF) files, or
coalescent simulations.
These variants can be simulated based on one of several popular
molecular-evolution models.
`jackelope` simulates single, paired-ended, or mate-pair reads on the Illumina platform,
and it generates Pacific Biosciences (PacBio) reads.
Both types of sequencing output to FASTQ files that can be optionally compressed.


After outlining the methods, I demonstrate the usefulness of `jackelope` in
informing study design through three common usage examples.







## Features and methods

Most code is written in C++ and interfaces with R using the `Rcpp` package
`r citep(citation("Rcpp")[1])`.
I used OpenMP to allow for parallel processing and
the `PCG` family of thread-safe, pseudo-random number generators
`r old_ref("Oneill_2014pcg")`.
Package `RcppProgress` provides the thread-safe progress bar
`r citep(citation("RcppProgress"))`.
An overview of the methods are show in Figure \@ref(fig:jackelope-overview).

```{r jackelope-overview-cap, include=FALSE}
go_cap <- paste("Overview of \\texttt{jackelope} functions, inputs, and outputs.",
                "``ms'' indicates \\texttt{ms}-style output from coalescent simulations.")
```
```{r jackelope-overview, out.width="100%", out.height="100%", fig.cap=go_cap}
# knitr::include_graphics("figs/jackelope.pdf", dpi = NA)
```





### The `ref_genome` class

Haploid reference genomes are represented by the class `ref_genome`, an
R6 `r citep(citation("R6"))` class that acts as a wrapper around a pointer to 
an underlying C++ object that stores all the sequence information.
They can be generated from FASTA files using the
function `read_fasta`.
This function also accepts FASTA index files---created using 
`samtools faidx`---for faster processing.
Both FASTA and index files can be either uncompressed or compressed using `gzip`.
If a reference genome is not available, the `create_genome` function creates 
a reference genome of given equilibrium nucleotide distributions, and mean and 
standard deviation of the sequence-length distribution.
I draw sequence lengths from a gamma distribution `r citep("10.1093/molbev/msr011")`.


The access provided by the R class `ref_genome` is designed to both 
maximize flexibility and minimize copying and the chances of
printing extremely large strings to the console.
Methods in `ref_genome` allow the user to view the
number of sequences, sequence sizes, sequence names, and individual sequence strings.
Users can also edit sequence names and remove one or more sequences by name.
Method `filter_sequences` filters genomes by the minimum sequence size or
by the smallest sequence that retains a given proportion of total reference
sequence if sequences are sorted by descending size.
Using method `merge_sequences`, users can shuffle reference sequences and
merge them into one.
Method `replace_Ns` replaces any `N`s in the reference sequence with random nucleotides,
optionally sampled with weights provided by the user.
Reference genomes can be written to FASTA files using the `write_fasta` function.




### The `mevo` class


The `mevo` class stores molecular evolution information for use in the
`create_variants` function, and is created using the `make_mevo` function.
Molecular evolution can include substitutions,
indels (insertions and deletions) of lengths up to $2^{31} - 1$,
and variation in mutation rates among sites.

The following substitution models can be employed:
TN93 `r old_ref('TN93')`,
JC69 `r old_ref('JC69')`,
K80 `r citep("10.1007/BF01731581")`,
F81 `r citep("10.1007/BF01734359")`,
HKY85 `r old_ref(c('Hasegawa_1985', 'Hasegawa_1984'))`, 
F84 `r old_ref("Thorne_1992")`,
GTR `r old_ref("Tavare_1986gtr")`,
and UNREST `r old_ref("Yang_1994")`.
If using the UNREST model, equilibrium nucleotide frequencies ($\mathbf{\pi}$) are 
calculated by solving for $\mathbf{\pi} \mathbf{Q} = 0$, where $\mathbf{Q}$ is the
substitution rate matrix.
This is done by finding the left eigenvector of $\mathbf{Q}$ that
corresponds to the eigenvalue closest to zero.

Insertions and deletions are generated the same and have the same requirements for 
inputs in the `make_mevo` function.
They first require an overall rate parameter, which is for the sum among all
nucleotides; indel rates do not differ among nucleotides.
Function `make_mevo` also requires information about the relative rates of
indels of different sizes, which can be provided in 3 different ways.
First, rates can be proportional to $\exp(-u)$ for indel length $u$ from
1 to the maximum possible length, $M$ `r citep("10.1101/gr.112326.110")`.
Second, rates can be generated from a Lavalette distribution, 
where the rate for length $u$ is proportional to
$\left[{u M / (M - u + 1)}\right]^{-a}$ `r citep("10.1093/molbev/msp098")`.
Third, relative rates can be specified directly by providing a length-$M$
numeric vector of positive values.


Among-site variation in mutation rates is included either by generating
gamma distances ($\gamma$) from a distribution or by passing them manually.
The overall mutation rate is $\gamma ~ q_{0}$, where
$q_{0}$ is the base mutation rate determined only by the nucleotide.
Gamma distances are generated from a Gamma distribution with a fixed mean of 1
and with a shape parameter provided by the user.
Users can also pass a list of matrices, one for each reference sequence,
with a gamma distance and end point for each sequence region.
The gamma distances can optionally be written to a BED file.




### The `variants` class


Variants from the reference genome are represented as haploid genomes
in the `variants` class.
Similarly to `ref_genome`, this R6 class wraps a pointer to a C++ object
that stores all the information, and it was designed to prevent copying of large
objects in memory.
The underlying C++ class also does not store whole variant genomes, but
rather just their mutation information---this dramatically reduces memory usage.
Variants can be created in five different ways, all of which are encompassed in the
`create_variants` function.


The first two methods directly specify numbers and locations of mutations and
therefore do not require any phylogenetic methods in `jackalope`.
First, a variant call format (VCF) file can directly specify mutations for each
variant.
This method works using the `vcfR` package `r citep(citation("vcfR"))` and
is the only method that does not require a `mevo` object.
Second, matrices of segregating sites from coalescent output can provide the locations
of mutations.
A `mevo` object then provides the type of mutation at each site.
The segregating-site information can take the form of 
(1\) a coalescent-simulator object from the `scrm` `r citep(citation("scrm"))` or
`coala` `r citep(citation("coala"))` package, or
(2\) a file containing output from a coalescent simulator in the format of the
`ms` `r citep("10.1093/bioinformatics/18.2.337")` or 
`msms` `r citep("10.1093/bioinformatics/btq322")` programs.


The last three methods require simulations along phylogenetic trees, which is outlined
in the following paragraph.
In the first of these phylogenetic methods,
phylogenetic tree(s) can be directly input from either `phylo` object(s) or
NEWICK file(s).
One tree can be used for all genome sequences, or each sequence can use a separate tree.
Alternatively, users can pass an estimate for $\theta$ (the population-scaled
mutation rate).
A random coalescent tree is first generated using the `rcoal` function
in the `ape` package `r citep(citation("ape"))`.
Then, its total tree length is scaled to be
$\theta / \mu \sum_{i=1}^{n-1}{1 / i}$ for $n$ variants and an equilibrium
mutation rate of $\mu$.
The last method allows for simulation of recombination by simulating along
gene trees that can differ both within and among reference sequences.
As for coalescent segregating sites, gene trees can be from `scrm` or `coala` objects,
or from `ms`-style output files.


Variants are simulated along tree branches by generating exponential wait times
for the Markov "jump" chain for each sequence,
where the rate of the exponential distribution is the sum of mutation rates for
each nucleotide in the sequence `r old_ref("Yang_2006")`.
At each jump, a position on the sequence is sampled with a probability proportional to
the mutation rate for that nucleotide.
To sample positions, I use weighted reservoir sampling with
exponential jumps `r citep("10.1016/j.ipl.2005.11.003")`.
To optionally improve performance for sampling long sequences,
a number of positions can be first uniformly sampled using
"Algorithm D" by `r citet("10.1145/358105.893")`, followed by weighted
sampling by rates.
After sampling a position, a mutation type is sampled with probabilities
proportional to the rate of each mutation type for the nucleotide
present at the sampled position.
I used alias sampling
`r citep(list("10.1049/el:19740097", "10.1080/00031305.1979.10482697"))`
for sampling mutation types.
Jumps are performed until the summed length of all jumps is greater than the
branch length.



Methods in `variants` allow the user to view the number of sequences/variants,
variant sequence sizes, sequence/variant names, and individual variant-sequence strings.
Users can also edit variant names, remove one or more variants by name,
and manually add mutations.
Variant information can be written to VCF files using the `write_vcf` function,
where each variant can optionally be considered one of multiple haplotypes for
samples with ploidy levels > 1.




### Simulate sequencing data


Both R6 classes `ref_genome` and `variants` can be input to the sequencing functions
`illumina` and `pacbio`.
If providing a `variants` object, you can specify sampling weights for each variant
to simulate the library containing differing amounts of DNA from each.
Both methods also allow for a probability of read duplication, which might occur
due to PCR in either method and from optical duplicates in Illumina sequencing.
Reads can be written using multiple threads by having a read "pool" for each thread 
and having pools write to file only when they are full.
This reduces conflicts that occur when multiple threads attempt to write to disk
at the same time.
The size of a "full" pool can be adjusted, and larger sizes should increase both
speed and memory usage.
Reads are output to FASTQ files, optionally with `gzip` compression.

Function `illumina` simulates single, paired-ended, or mate-pair Illumina reads,
while `pacbio` simulates reads from the Pacific Biosciences (PacBio) platform.
Illumina read simulation is based on the ART program
`r citep("10.1093/bioinformatics/btr708")`, and
PacBio read simulation is based on SimLoRD `r citep("10.1093/bioinformatics/btw286")`.
Function inputs emulate the program they were based on.




## Performance

Performance was tested on a 2013 MacBook Pro running macOS High Sierra with a 
2.6GHz Intel Core i5 processor and 8 GB RAM.
I compared the performance of `jackalope` functions to those in other packages based on 
the time and maximum RAM required for each to perform its task.
RAM usage is presented as the maximum usage during an R session where the only
actions taken were to load the necessary package and run the function.
Thus overhead associated with loading a package is included.
For functions in packages outside `jackalope`, I use the R convention of
displaying them as the package name, two colons, then the function name
(i.e., `Package::Function`).







## Conclusion

`jackalope` outperforms current programs while providing a more flexible platform.
This package should inform research design for projects employing HTS,
particularly those in population genomics.
Output from `jackalope` will help develop more specific sequencing goals 
in funding applications and estimate the power of a given sequencing design.
Furthermore, `jackalope` can be used to test bioinformatic pipelines under assumptions of
much more complex demographic histories than current HTS simulation 
platforms allow.



# References

```{r biblio, message = FALSE, eval = TRUE}
write.bibtex(file="references.bib")
```
