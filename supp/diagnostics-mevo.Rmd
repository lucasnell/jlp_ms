---
editor_options: 
  chunk_output_type: console
---


```{r mevo-setup, include=FALSE, cache = FALSE, eval = FALSE}
suppressPackageStartupMessages({
    library(jackalope)
    library(tidyverse)
    library(scrm)
    library(grid)
    library(ape)
})
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, dev = 'quartz_pdf')
# knitr::opts_knit$set(root.dir = normalizePath(".."))
if (isTRUE(getOption('knitr.in.progress'))) knitr::knit_theme$set(knitr::knit_theme$get("acid"))

if (!isTRUE(getOption('knitr.in.progress'))) {
    options("device" = "quartz")
    grDevices::graphics.off()
}
theme_set(theme_classic() + 
              theme(legend.background = element_blank(),
                    strip.background = element_blank(),
                    plot.margin = margin(0.5, 0.5, 0.5, 0.5)))

# Saves our temporary directory to store some files:
dir <- paste0(tempdir(check = TRUE), "/")
```



```{r mevo-simulate}

# simulate ----

# Set all needed molecular evolution parameters inside an environment (using TN93 method)
pars <- new.env()
with(pars, {
    n_seqs <- 20
    # Molecular evolution parameters:
    pi_tcag = c(0.1, 0.2, 0.3, 0.4)
    alpha_1 = 0.25
    alpha_2 = 0.35
    beta = 0.5
    #   For indels:
    rates = c(0.2, 0.3)
    M = c(8L, 10L)
    a = c(0.1, 0.5)
    n_vars = 10
    #   For site variability:
    shape = 0.5
    region_size = 1e3
    seq_len = 100e3
    ends = seq(region_size, seq_len, region_size)
    mats = replicate(n_seqs,
                     cbind(ends, rgamma(length(ends), shape = shape, rate = shape)),
                     simplify = FALSE)
    # Construct sequences with known number of each nucleotide
    seqs <- rep(list(c(rep("T", 0.25 * seq_len), rep("C", 0.25 * seq_len),
                       rep("A", 0.25 * seq_len), rep("G", 0.25 * seq_len))),
                n_seqs)
    seqs <- lapply(seqs, sample)
    seqs <- sapply(seqs, paste, collapse = "")
})


set.seed(1087437799)

# Make ref_genome object from a pointer to a RefGenome object based on `seqs`
ref <- with(pars, ref_genome$new(jackalope:::make_ref_genome(seqs)))



# For testing: just one individual at known sites
coal_obj <- scrm("2 20 -r 3.1 1000 -t 1000")
coal_obj$seg_sites <- map(coal_obj$seg_sites, ~ .x[1,.x[1,] > 0,drop=FALSE])
```



## Indel rates

```{r mevo-indels}
# Function to calculate the expected proportion of mutations that are
# insertions or deletions of a given size:
indel_pred <- function(u, j, q_) {
    # < indel of type j > / < all mutations >
    ijp <- pars$rates[j] / sum(q_)
    # < indel of type j and size u > / < indel of type j >
    M_ <- pars$M[j]
    a_ <- pars$a[j]
    u_ <- 1:M_
    all_ps <- {(u_ * M_) / (M_ - u_ + 1)}^(-a_)
    piju <- all_ps[u] / sum(all_ps)
    return(ijp * piju)
}

# Function to make a matrix have N columns
make_N <- function(x, N) cbind(x, matrix(0, nrow(x), N - ncol(x)))

# --------------------*
# Insertions ----
# --------------------*

# Only insertions:
Q <- sub_TN93(alpha_1 = 0,
              alpha_2 = 0, beta = 0,
              pi_tcag = pars$pi_tcag)
insertions <- indels(rate = pars$rates[1],
                     max_length = pars$M[1],
                     a = pars$a[1])
var_set <- create_variants(ref, vars_ssites(coal_obj),
                           sub = Q,
                           ins = insertions)

rates_ <- jackalope:::create_mevo(ref, sub = Q, ins = insertions, NULL, NULL, 100)$q()

insertions <- map(0:(pars$n_seqs-1),
             function(s) {
                 Z <- jackalope:::examine_mutations(var_set_ptr = var_set$genomes,
                                                 var_ind = 0, seq_ind = s) %>%
                     .[["ins"]]
                 # Anything over `pars$M[1]` is >1 mutation
                 if (ncol(Z) > pars$M[1]) Z <- Z[,1:pars$M[1],drop=FALSE]
                 # Make sure it has exactly pars$M[1] columns for binding
                 if (ncol(Z) < pars$M[1]) Z <- make_N(Z, pars$M[1])
                 return(colSums(Z))
             })%>%
    do.call(what = rbind) %>%
    colSums()


ins_df <- tibble(pred = indel_pred(1:pars$M[1], 1, rates_) * sum(insertions),
                 obs = insertions)


ins_p <- ins_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted insertion count") +
    scale_y_continuous("Observed insertion count") +
    theme_classic() + 
    coord_equal()




# --------------------*
# Deletions ----
# --------------------*

# Only deletions
Q <- sub_TN93(alpha_1 = 0,
              alpha_2 = 0, beta = 0,
              pi_tcag = pars$pi_tcag)
deletions <- indels(rate = pars$rates[2],
                    max_length = pars$M[2],
                    a = pars$a[2])
var_set <- create_variants(ref, vars_ssites(coal_obj),
                           sub = Q,
                           del = deletions)

rates_ <- jackalope:::create_mevo(ref, sub = Q, del = deletions, NULL, NULL, 100)$q()


deletions <- map(0:(pars$n_seqs-1),
                  function(s) {
                      Z <- jackalope:::examine_mutations(var_set_ptr = var_set$genomes,
                                                      var_ind = 0, seq_ind = s) %>%
                          .[["del"]]
                      # Anything over `pars$M[1]` is >1 mutation
                      if (ncol(Z) > pars$M[2]) Z <- Z[,1:pars$M[2],drop=FALSE]
                      # Make sure it has exactly pars$M[1] columns for binding
                      if (ncol(Z) < pars$M[2]) Z <- make_N(Z, pars$M[2])
                      return(colSums(Z))
                  })%>%
    do.call(what = rbind) %>%
    colSums()


del_df <- tibble(pred = indel_pred(1:pars$M[2], 2, rates_) * sum(deletions),
                 obs = deletions)


del_p <- del_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted deletion count") +
    scale_y_continuous("Observed deletion count") +
    theme_classic() +
    coord_equal()



grid.newpage()
grid.draw(rbind(ggplotGrob(del_p), ggplotGrob(ins_p), size = "last"))

```



## Substitution rates

```{r mevo-sub_rates}
# Phylogenetic tree:
tree <- ape::rcoal(2)
tree$edge.length <- tree$edge.length * 0.1

Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2,
              beta = pars$beta,
              pi_tcag = pars$pi_tcag)

# Only substitutions
var_set <- create_variants(ref, vars_phylo(tree),
                           sub = Q)

substitutions <- map(0:(pars$n_seqs-1),
                     function(s) {
                         Z <- jackalope:::examine_mutations(var_set_ptr = var_set$genomes,
                                                     var_ind = 0, seq_ind = s) %>%
                         .[["sub"]]
                     return(Z)
                 }) %>%
    Reduce(f = `+`)
# Predicted values:
sub_pred <- sum(substitutions) * (Q$Q / sum(Q$Q))

sub_df <- tibble(obs = c(substitutions[lower.tri(substitutions)],
                         substitutions[upper.tri(substitutions)]),
                 pred = c(sub_pred[lower.tri(sub_pred)],
                          sub_pred[upper.tri(sub_pred)]))


sub_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted substitution count") +
    scale_y_continuous("Observed substitution count") +
    theme_classic() +
    coord_equal()
```





## Among-site variation


```{r mevo-site-var}
ref <- with(pars, ref_genome$new(jackalope:::make_ref_genome(seqs[1:4])))

# Only substitutions plus gammas
Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2, beta = pars$beta,
              pi_tcag = pars$pi_tcag)
gm <- site_var(ref, mats = pars$mats[1:ref$n_seqs()])
# Takes ~14 sec
var_set <- create_variants(ref, vars_phylo(tree), sub = Q, 
                           gamma_mats = gm,
                           n_threads = 4)

pos_df <- map_dfr(0:(ref$n_seqs()-1),
    function(s) {
        Z <- jackalope:::examine_mutations(var_set_ptr = var_set$genomes,
                                        var_ind = 0, seq_ind = s) %>%
            .[["pos"]]
        return(tibble(seq = as.integer(s), pos = as.integer(Z)))
    })

gamm_df <- map_dfr(0:(ref$n_seqs()-1),
    function(s) {
        gamma_mat <- gm[[s+1]]
        Z <- pos_df[pos_df$seq == s, ][["pos"]]
        # Expected # mutations per gamma region:
        pred_mut = length(Z) / nrow(gamma_mat)
        df_ <- tibble(seq = s,
                      gamma = gamma_mat[,2],
                      pos = gamma_mat[,1],
                      obs = jackalope:::table_gammas(gamma_mat[,1], Z))
        df_$pred <- (df_$gamma / sum(df_$gamma)) * sum(df_$obs)
        return(df_)
    })


gamm_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted mutation count") +
    scale_y_continuous("Observed mutation count") +
    theme_classic() +
    coord_equal()
```





## Phylogeny

```{r mevo-phylogeny}
# Phylogenetic tree:
set.seed(89415648)
tree <- ape::rcoal(pars$n_vars)
tree$edge.length <- tree$edge.length * 0.1

ref <- with(pars, ref_genome$new(jackalope:::make_ref_genome(seqs[1:4])))
# Only substitutions again
Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2, beta = pars$beta,
              pi_tcag = pars$pi_tcag)

var_set <- create_variants(ref, vars_phylo(tree), sub = Q, n_threads = 4)


mutations <- lapply(0:(pars$n_vars-1),
                    function(v) {
                        Z <- jackalope:::view_mutations(var_set_ = var_set$genomes,
                                                     var_ind = v)
                        Zseq <- Z[,"seq"]
                        Z <- Z[, c("old_pos", "size_mod", "nucleos")]
                        ZZ <- apply(Z, 1, function(xx) gsub(" ", "",
                                                            paste(xx, collapse = "_")))
                        return(split(ZZ, Zseq))
                    })



shared_muts <- rep(list(matrix(0L, pars$n_vars, pars$n_vars)), ref$n_seqs())
for (s in 1:(ref$n_seqs())) {
    for (i in 1:(pars$n_vars-1)) {
        for (j in (i+1):(pars$n_vars)) {
            muts1 <- mutations[[i]][[s]]
            muts2 <- mutations[[j]][[s]]
            shared_muts[[s]][i,j] <- as.integer(sum(muts2 %in% muts1))
            shared_muts[[s]][j,i] <- as.integer(sum(muts1 %in% muts2))
        }
    }
    diag(shared_muts[[s]]) <- sapply(mutations, function(x) length(x[[s]]))
}; rm(s, i, j, muts1, muts2)


# "Mutational" distances between all pairs:
mut_dists <- rep(list(matrix(0L, pars$n_vars, pars$n_vars)), ref$n_seqs())
for (s in 1:(ref$n_seqs())) {
    for (i in 1:(pars$n_vars-1)) {
        for (j in (i+1):pars$n_vars) {
            # Total non-shared mutations for each:
            mut_dists[[s]][i,j] <- shared_muts[[s]][i,i] - shared_muts[[s]][i,j]
            mut_dists[[s]][j,i] <- shared_muts[[s]][j,j] - shared_muts[[s]][j,i]
        }
    }
}; rm(s, i, j)


# Phylogenetic distances between all pairs:
phylo_dists <- ape::cophenetic.phylo(tree)
rownames(phylo_dists) <- colnames(phylo_dists) <- NULL
# Dividing by two to get branch lengths between MRCA:
phylo_dists <- phylo_dists / 2


# Average mutation rate for ancestral sequences times total bp in each sequence:
mu_ <- mean(jackalope:::create_mevo(ref, sub = Q, NULL, NULL, NULL, 100)$q()) *
    mean(nchar(pars$seqs[1:4]))

# Expected mutational distances:
pred_mut_dists <- mu_ * phylo_dists


phy_df <- tibble(obs = lapply(mut_dists,
                              function(x) c(x[lower.tri(x)], x[upper.tri(x)])) %>%
                     do.call(what = c),
                 pred = rep(c(pred_mut_dists[lower.tri(pred_mut_dists)],
                              pred_mut_dists[upper.tri(pred_mut_dists)]),
                            ref$n_seqs()))

phy_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted mutation count") +
    scale_y_continuous("Observed mutation count") +
    theme_classic() +
    coord_equal()
```
