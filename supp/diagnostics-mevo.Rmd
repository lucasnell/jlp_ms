---
editor_options: 
  chunk_output_type: console
---


```{r mevo-setup, include=FALSE, cache = FALSE, eval = FALSE}
suppressPackageStartupMessages({
    library(jackalope)
    library(tidyverse)
    library(scrm)
    library(grid)
    library(ape)
})
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, dev = 'quartz_pdf')
# knitr::opts_knit$set(root.dir = normalizePath(".."))
if (isTRUE(getOption('knitr.in.progress'))) knitr::knit_theme$set(knitr::knit_theme$get("acid"))

if (!isTRUE(getOption('knitr.in.progress'))) {
    options("device" = "quartz")
    grDevices::graphics.off()
}
theme_set(theme_classic() + 
              theme(legend.background = element_blank(),
                    strip.background = element_blank(),
                    plot.margin = margin(0.5, 0.5, 0.5, 0.5)))

# Saves our temporary directory to store some files:
dir <- paste0(tempdir(check = TRUE), "/")
```


This tests that when creating variants, `jackalope` produces substitutions, indels,
and among-site variation that fit expectations.
It lastly checks that when simulating along a phylogeny, the number of 
differences between individual variants is proportional to the phylogenetic distance
between them.
The reference genome used in this section is displayed below:

```{r mevo-simulate}

set.seed(1087437799)

# simulate ----

# Set all needed molecular evolution parameters inside an environment (using TN93 method)
pars <- new.env()
with(pars, {
    n_seqs <- 20
    # Molecular evolution parameters:
    pi_tcag = c(0.1, 0.2, 0.3, 0.4)
    alpha_1 = 0.25
    alpha_2 = 0.35
    beta = 0.5
    #   For indels:
    rates = c(0.2, 0.3)
    M = c(8L, 10L)
    a = c(0.1, 0.5)
    n_vars = 10
    #   For site variability:
    shape = 0.5
    region_size = 1e3
    seq_len = 100e3
    ends = seq(region_size, seq_len, region_size)
    mats = replicate(n_seqs,
                     cbind(ends, rgamma(length(ends), shape = shape, rate = shape)),
                     simplify = FALSE)
    # Construct sequences with known number of each nucleotide
    seqs <- rep(list(c(rep("T", 0.25 * seq_len), rep("C", 0.25 * seq_len),
                       rep("A", 0.25 * seq_len), rep("G", 0.25 * seq_len))),
                n_seqs)
    seqs <- lapply(seqs, sample)
    seqs <- sapply(seqs, paste, collapse = "")
})

# Make ref_genome object from a pointer to a RefGenome object based on `seqs`
ref <- with(pars, ref_genome$new(jackalope:::make_ref_genome(seqs)))
ref


# For testing: just one individual at known sites
coal_obj <- scrm("2 20 -r 3.1 1000 -t 1000")
coal_obj$seg_sites <- map(coal_obj$seg_sites, ~ .x[1,.x[1,] > 0,drop=FALSE])
```





## Substitution rates

```{r illumina-sub-cap-inputs}
# Phylogenetic tree:
tree <- ape::rcoal(2)
tree$edge.length <- tree$edge.length * 0.1

Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2,
              beta = pars$beta,
              pi_tcag = pars$pi_tcag)

ill_sub_cap <- paste("Observed versus predicted substitutions for simulation of",
                     "2 variants along a phylogeny.")
```

This simulates just substitutions along a phylogeny of 2 variants, with
a branch length of `r signif(tree$edge.length[1], 3)` and with the following
substitution rate matrix:

```{r mevo-sub-mat}
prmatrix(Q$Q, digits = 3,
         rowlab = paste("  ", c("T", "C", "A", "G")),
         collab = c("T", "C", "A", "G"))
```



```{r mevo-sub-rates, fig.cap=ill_sub_cap}

# Only substitutions
var_set <- create_variants(ref, vars_phylo(tree),
                           sub = Q)

substitutions <- map(0:(pars$n_seqs-1),
                     function(s) {
                         Z <- jackalope:::examine_mutations(var_set_ptr = var_set$ptr(),
                                                     var_ind = 0, seq_ind = s) %>%
                         .[["sub"]]
                     return(Z)
                 }) %>%
    Reduce(f = `+`)
# Predicted values:
sub_pred <- sum(substitutions) * (Q$Q / sum(Q$Q))

sub_df <- tibble(obs = c(substitutions[lower.tri(substitutions)],
                         substitutions[upper.tri(substitutions)]),
                 pred = c(sub_pred[lower.tri(sub_pred)],
                          sub_pred[upper.tri(sub_pred)]))


sub_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted substitution count") +
    scale_y_continuous("Observed substitution count") +
    coord_equal()
```



## Indel rates

In this section, I simulated everything the same except that I had no substitutions
and indel rates were $> 0$.
In the first set of simulations, the deletion rate was zero and 
the insertion rate was `r pars$rates[1]`.
In the second set, the insertion rate was zero and the deletion rate was
`r pars$rates[2]`.
```{r mevo-indels-caption}
ind_cap <- paste("Observed versus predicted insertions (left) and deletions (right)",
                 "for simulation of 2 variants along a phylogeny.")
```


```{r mevo-indels, fig.height=3, fig.width=6, fig.cap=ind_cap}
# Function to calculate the expected proportion of mutations that are
# insertions or deletions of a given size:
indel_pred <- function(u, j, q_) {
    # < indel of type j > / < all mutations >
    ijp <- pars$rates[j] / sum(q_)
    # < indel of type j and size u > / < indel of type j >
    M_ <- pars$M[j]
    a_ <- pars$a[j]
    u_ <- 1:M_
    all_ps <- {(u_ * M_) / (M_ - u_ + 1)}^(-a_)
    piju <- all_ps[u] / sum(all_ps)
    return(ijp * piju)
}

# Function to make a matrix have N columns
make_N <- function(x, N) cbind(x, matrix(0, nrow(x), N - ncol(x)))

# --------------------*
# Insertions ----
# --------------------*

# Only insertions:
Q <- sub_TN93(alpha_1 = 0,
              alpha_2 = 0, beta = 0,
              pi_tcag = pars$pi_tcag)
insertions <- indels(rate = pars$rates[1],
                     max_length = pars$M[1],
                     a = pars$a[1])
var_set <- create_variants(ref, vars_ssites(coal_obj),
                           sub = Q,
                           ins = insertions)

rates_ <- jackalope:::create_mevo(ref, sub = Q, ins = insertions, NULL, NULL, 100)$q()

insertions <- map(0:(pars$n_seqs-1),
             function(s) {
                 Z <- jackalope:::examine_mutations(var_set_ptr = var_set$ptr(),
                                                 var_ind = 0, seq_ind = s) %>%
                     .[["ins"]]
                 # Anything over `pars$M[1]` is >1 mutation
                 if (ncol(Z) > pars$M[1]) Z <- Z[,1:pars$M[1],drop=FALSE]
                 # Make sure it has exactly pars$M[1] columns for binding
                 if (ncol(Z) < pars$M[1]) Z <- make_N(Z, pars$M[1])
                 return(colSums(Z))
             })%>%
    do.call(what = rbind) %>%
    colSums()


ins_df <- tibble(pred = indel_pred(1:pars$M[1], 1, rates_) * sum(insertions),
                 obs = insertions)



# --------------------*
# Deletions ----
# --------------------*

# Only deletions
Q <- sub_TN93(alpha_1 = 0,
              alpha_2 = 0, beta = 0,
              pi_tcag = pars$pi_tcag)
deletions <- indels(rate = pars$rates[2],
                    max_length = pars$M[2],
                    a = pars$a[2])
var_set <- create_variants(ref, vars_ssites(coal_obj),
                           sub = Q,
                           del = deletions)

rates_ <- jackalope:::create_mevo(ref, sub = Q, del = deletions, NULL, NULL, 100)$q()


deletions <- map(0:(pars$n_seqs-1),
                  function(s) {
                      Z <- jackalope:::examine_mutations(var_set_ptr = var_set$ptr(),
                                                      var_ind = 0, seq_ind = s) %>%
                          .[["del"]]
                      # Anything over `pars$M[1]` is >1 mutation
                      if (ncol(Z) > pars$M[2]) Z <- Z[,1:pars$M[2],drop=FALSE]
                      # Make sure it has exactly pars$M[1] columns for binding
                      if (ncol(Z) < pars$M[2]) Z <- make_N(Z, pars$M[2])
                      return(colSums(Z))
                  })%>%
    do.call(what = rbind) %>%
    colSums()


del_df <- tibble(pred = indel_pred(1:pars$M[2], 2, rates_) * sum(deletions),
                 obs = deletions)


# ---------*
# Plots
# ---------*


ins_p <- ins_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted insertion count") +
    scale_y_continuous("Observed insertion count") +
    coord_equal()

del_p <- del_df %>%
    ggplot(aes(pred, obs)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted deletion count") +
    scale_y_continuous("Observed deletion count") +
    coord_equal()



grid.newpage()
grid.draw(cbind(ggplotGrob(ins_p), ggplotGrob(del_p), size = "last"))

```






## Among-site variation

In this set of simulations, I had only substitutions because insertions and deletions
cause more extreme changes in overall mutation rates for regions.
I used the same substitution rate matrix as in the "Substitution rates" section.
For among-site variability, I used 100 manually created, equally sized regions per
sequence, each of which had its own "gamma distance" that should be proportional
to the number of mutations that occurred within it.
After the variants were created, I counted the number of mutations per region
and related it to its gamma distance.



```{r mevo-site-var-cap}
sv_cap <- paste("Observed versus predicted number of mutations that occurred in",
                "each region, based on each region's gamma distance.",
                "The dashed line is the 1-to-1 line.")
```

```{r mevo-site-var, fig.cap = sv_cap}
# Only substitutions plus gammas
Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2, beta = pars$beta,
              pi_tcag = pars$pi_tcag)
gm <- site_var(ref, mats = pars$mats[1:ref$n_seqs()])

var_set <- create_variants(ref, vars_phylo(tree), sub = Q, 
                           gamma_mats = gm)

pos_df <- map_dfr(0:(ref$n_seqs()-1),
    function(s) {
        Z <- jackalope:::examine_mutations(var_set_ptr = var_set$ptr(),
                                        var_ind = 0, seq_ind = s) %>%
            .[["pos"]]
        return(tibble(seq = as.integer(s), pos = as.integer(Z)))
    })

gamm_df <- map_dfr(0:(ref$n_seqs()-1),
    function(s) {
        gamma_mat <- gm[[s+1]]
        Z <- pos_df[pos_df$seq == s, ][["pos"]]
        # Expected # mutations per gamma region:
        pred_mut = length(Z) / nrow(gamma_mat)
        df_ <- tibble(seq = s,
                      gamma = gamma_mat[,2],
                      pos = gamma_mat[,1],
                      obs = jackalope:::table_gammas(gamma_mat[,1], Z))
        df_$pred <- (df_$gamma / sum(df_$gamma)) * sum(df_$obs)
        return(df_)
    })


gamm_df %>%
    ggplot(aes(pred, obs)) +
    geom_point(shape = 1, alpha = 0.25) +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted mutation count") +
    scale_y_continuous("Observed mutation count") +
    coord_equal()
```





## Phylogeny


For this section, I simulated 10 variants along the following phylogenetic tree:


```{r mevo-phylogeny-phylo, fig.height=4, fig.width=5, fig.cap="Phylogeny of 10 simulated variants."}
# Phylogenetic tree:
set.seed(89415648)
tree <- ape::rcoal(pars$n_vars)
tree$edge.length <- tree$edge.length * 0.1

mp_cap <- paste("Observed versus predicted numbers of unshared mutations",
                "between", pars$n_vars, "variants created by simulating along",
                "a phylogeny.",
                "Each point represents the number of unshared mutations between",
                "two variants for one of the", ref$n_seqs(), "sequences.",
                "The dashed line is the 1-to-1 line.")

plot(tree)
```


I used only substitutions in the simulations, to make matching mutations between
variants more straightforward.

I calculated the number of unshared mutations between variants $i$ and $j$ as
the total number of mutations in variant $i$ minus the number of mutations shared
between them.
I did not also include the calculation using the total mutations for variant $j$
since that was redundant (and does not change my conclusions).
I then calculated the phylogenetic distances between them using the function
`ape::cophenetic.phylo` and dividing the output by 2 to get the time since
the most recent common ancestor.
Next, I multipled these distances by the mean mutation rate (based on the
substitution rate matrix) and the mean number of basepairs in each reference genome
sequence.
This gave me the predicted number of unshared mutations.



```{r mevo-phylogeny-plot, fig.cap=mp_cap}
# Only substitutions again
Q <- sub_TN93(alpha_1 = pars$alpha_1,
              alpha_2 = pars$alpha_2, beta = pars$beta,
              pi_tcag = pars$pi_tcag)

var_set <- create_variants(ref, vars_phylo(tree), sub = Q, n_threads = 4)


mutations <- lapply(0:(pars$n_vars-1),
                    function(v) {
                        Z <- jackalope:::view_mutations(var_set_ = var_set$ptr(),
                                                     var_ind = v)
                        Zseq <- Z[,"seq"]
                        Z <- Z[, c("old_pos", "size_mod", "nucleos")]
                        ZZ <- apply(Z, 1, function(xx) gsub(" ", "",
                                                            paste(xx, collapse = "_")))
                        return(split(ZZ, Zseq))
                    })



shared_muts <- rep(list(matrix(0L, pars$n_vars, pars$n_vars)), ref$n_seqs())
for (s in 1:(ref$n_seqs())) {
    for (i in 1:(pars$n_vars-1)) {
        for (j in (i+1):(pars$n_vars)) {
            muts1 <- mutations[[i]][[s]]
            muts2 <- mutations[[j]][[s]]
            shared_muts[[s]][i,j] <- as.integer(sum(muts1 %in% muts2))
            shared_muts[[s]][j,i] <- as.integer(sum(muts2 %in% muts1))
        }
    }
    diag(shared_muts[[s]]) <- sapply(mutations, function(x) length(x[[s]]))
}; rm(s, i, j, muts1, muts2)


# "Mutational" distances between all pairs:
mut_dists <- rep(list(matrix(0L, pars$n_vars, pars$n_vars)), ref$n_seqs())
for (s in 1:(ref$n_seqs())) {
    for (i in 1:(pars$n_vars-1)) {
        for (j in (i+1):pars$n_vars) {
            # Total non-shared mutations for each:
            mut_dists[[s]][i,j] <- shared_muts[[s]][i,i] - shared_muts[[s]][i,j]
            mut_dists[[s]][j,i] <- shared_muts[[s]][j,j] - shared_muts[[s]][j,i]
        }
    }
}; rm(s, i, j)


# Phylogenetic distances between all pairs:
phylo_dists <- ape::cophenetic.phylo(tree)
rownames(phylo_dists) <- colnames(phylo_dists) <- NULL
# Dividing by two to get branch lengths between MRCA:
phylo_dists <- phylo_dists / 2


# Average mutation rate for ancestral sequences times total bp in each sequence:
mu_ <- mean(jackalope:::create_mevo(ref, sub = Q, NULL, NULL, NULL, 100)$q()) *
    mean(nchar(pars$seqs))

# Expected mutational distances:
pred_mut_dists <- mu_ * phylo_dists


phy_df <- tibble(obs = lapply(mut_dists,
                              function(x) x[lower.tri(x)]) %>%
                     do.call(what = c),
                 pred = rep(pred_mut_dists[lower.tri(pred_mut_dists)],
                            ref$n_seqs()))

phy_df %>%
    ggplot(aes(pred, obs)) +
    geom_point(alpha = 0.5, shape = 1) +
    geom_abline(slope = 1, intercept = 0, linetype = 2, color = "firebrick2") +
    scale_x_continuous("Predicted unshared mutations count") +
    scale_y_continuous("Observed unshared mutations count") +
    coord_equal()
```
