\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[12pt,]{article}
\usepackage{lmodern}
\usepackage{setspace}
\setstretch{2}
\usepackage{bbm}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{unicode-math}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={jackalope: a swift, lightweight phylogenomic and high-throughput sequencing simulator},
            colorlinks=true,
            linkcolor=Blue,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[left=2.5cm,right=2.5cm,top=3cm,bottom=3cm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\AttributeTok}[1]{#1}
\newcommand{\BaseNTok}[1]{#1}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\ConstantTok}[1]{#1}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.00,1.00}{#1}}
\newcommand{\DataTypeTok}[1]{#1}
\newcommand{\DecValTok}[1]{#1}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{#1}
\newcommand{\FunctionTok}[1]{#1}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.00,1.00}{#1}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{#1}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{1.00,0.25,0.00}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{1.00,0.25,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{#1}}
\newcommand{\VariableTok}[1]{#1}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\usepackage[labelfont=bf]{caption}
    \usepackage{longtable,booktabs}
            % Fix footnotes in tables (requires footnote package)
        \IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
    \usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure and tabke placement
\usepackage{float}
\makeatletter
\def\fps@figure{H}
\def\fps@table{H}
\makeatother

% Add S to the beginning of figure and table labels if it's supplemental section


\usepackage{authblk,etoolbox}
\renewcommand\Affilfont{\small}
\makeatletter
% % patch \maketitle so that it doesn't center
% \patchcmd{\@maketitle}{center}{flushleft}{}{}
% \patchcmd{\@maketitle}{center}{flushleft}{}{}

% patch the patch by authblk so that the author block is flush left
\def\maketitle{{%
  \renewenvironment{tabular}[2][]
    {\begin{flushleft}}
    {\end{flushleft}}
  \AB@maketitle}}
\makeatother


\providecommand{\subtitle}[1]{\Huge{#1}}

\title{
    jackalope: a swift, lightweight phylogenomic and high-throughput sequencing simulator
            }
            \author[1]{Lucas A. Nell}
                \affil[1]{Department of Integrative Biology, University of Wisconsin--Madison}
    % % \author{true}
% % \date{}
\date{}

\newcommand{\mean}[1]{\text{mean}\left( #1 \right)}
\newcommand{\var}[1]{\text{var}\left( #1 \right)}

% Removing extra space around \left( and \right)
\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}


\usepackage{multirow}
\usepackage{array}
\usepackage{makecell}
\usepackage{rotating} % To display tables in landscape
\usepackage{siunitx} % Required for alignment


\usepackage{lineno}
\linenumbers


\begin{document}

            \maketitle
        



\raggedright

\hypertarget{abstract}{%
\subsection{Abstract}\label{abstract}}

High-throughput sequencing (HTS) is central to the study of population genomics
and has an increasingly important role in constructing phylogenies.
Choices in sampling design for sequencing projects can include
a wide range of factors, including sequencing platform, depth of coverage, and
bioinformatic tools.
These choices are most often informed by previous work on highly diverged species,
which ignores species- and population-specific genomic characteristics
and evolutionary histories.
Simulating sequencing based on available genomic data better informs research design.
However, most current methods provide only rudimentary ways to simulate past
evolutionary events.
More recent pipelines have been developed that can simulate more complex scenarios,
but they involve installing and learning to operate multiple separate programs.
Here I present the R package \texttt{jackalope} that simply and efficiently simulates
(i) variants from reference genomes and
(ii) reads from both Illumina and Pacific Biosciences (PacBio) platforms.
It can either read reference genomes from FASTA files or simulate new ones.
Genomic variants can be simulated using summary statistics, phylogenies,
Variant Call Format (VCF) files, and coalescent simulations---the latter of which can
include selection, recombination, and demographic fluctuations.
\texttt{jackalope} can simulate single, paired-end, or mate-pair Illumina reads,
as well as reads from Pacific Biosciences.
These simulations include sequencing errors, mapping qualities, multiplexing,
and optical/PCR duplicates.
All outputs can be written to standard file formats.
Most functions are written in C++ to improve performance, and I employed OpenMP to
allow for parallel processing.

\textbf{Keywords:} sequencing simulator, population genomics, phylogenomics,
Illumina, Pacific Biosciences, Pool-seq

\hypertarget{introduction}{%
\subsection{Introduction}\label{introduction}}

High-throughput sequencing (HTS) is a cost-effective approach to generate vast amounts
of genomic data and has revolutionized the study of genomes
(Metzker, 2009).
The combination of massive datasets, sequencing errors, and potentially complex
evolutionary histories make bioinformatic pipelines an important aspect of
research using HTS.
Many bioinformatic tools exist, and new programs that are more accurate and
computationally efficient are constantly being developed.
To test these tools against known parameter values, simulation of HTS data is needed.
Although there are many sequence simulators currently available
(reviewed in Escalona, Rocha, \& Posada, 2016),
most have only rudimentary ways to generate variants from a reference genome.

Recently, pipelines have been developed that use multiple programs
to simulate complex evolutionary histories and HTS on the resulting populations
or species.
\texttt{TreeToReads} can simulate sequences along a single phylogenetic tree
(McTavish et al., 2017)
\texttt{NGSphy} can generate sequences from multiple gene trees
(Escalona, Rocha, \& Posada, 2018);
both generate Illumina reads.
These pipelines are quite powerful and useful to those seeking to simulate
HTS data under realistic evolutionary scenarios.
However, both pipelines require the installation of multiple programs to use them,
and the vast array of features creates a steep learning curve when getting started.
Additionally, the lack of integration between inner programs means that the
entire process is not as computationally efficient as a single standalone program.

In the present paper I introduce \texttt{jackalope}, the first available high-throughput
DNA-sequencing simulator for R
(R Core Team, 2019).
Designed for efficient memory use, flexibility, and speed,
\texttt{jackalope} combines the functionality of an HTS simulator with that of a
phylogenomics simulator.
Genomes can be derived from FASTA files or simulated in silico.
\texttt{jackalope} can create variants from the reference genome based on basic
population-genomic summary statistics, phylogenies, gene trees,
Variant Call Format (VCF) files, or matrices of segregating sites.
These variants can be simulated based on any of several popular
molecular-evolution models.
\texttt{jackalope} simulates single, paired-ended, or mate-pair reads on the Illumina platform,
as well as Pacific Biosciences (PacBio) reads.
All information generated by \texttt{jackalope} can be output to standard file formats.

After outlining the methods, I compare the performance of \texttt{jackalope} to that of
other popular programs.
Lastly, I demonstrate the usefulness of \texttt{jackalope} through three usage examples.

\hypertarget{features-and-methods}{%
\subsection{Features and methods}\label{features-and-methods}}

Most code is written in C++ and interfaces with R using the \texttt{Rcpp} package
(Eddelbuettel \& François, 2011).
I used OpenMP to allow for parallel processing and
the \texttt{PCG} family of thread-safe, pseudo-random number generators
(O'Neill, 2014).
Package \texttt{RcppProgress} provides the thread-safe progress bar
(Forner, 2018).
All input and output files can have \texttt{gzip} or \texttt{bgzip} compression, using the
\texttt{zlib} and
\texttt{htslib}
(Li et al., 2009)
libraries.
Access to these libraries uses the R packages
\texttt{zlibbioc} (Morgan, 2019) and
\texttt{Rhtslib} (Hayden \& Morgan, 2019)
to improve portability.
An overview of the methods is show in Figure \ref{fig:jackalope-overview-figure}.

\hypertarget{the-ref_genome-class}{%
\subsubsection{\texorpdfstring{The \texttt{ref\_genome} class}{The ref\_genome class}}\label{the-ref_genome-class}}

Haploid reference genomes are represented by the class \texttt{ref\_genome}, an
\texttt{R6} (Chang, 2019)
class that acts as a wrapper around a pointer to
an underlying C++ object that stores all the sequence information.
They can be generated from FASTA files using the function \texttt{read\_fasta}.
This function also accepts FASTA index files---created using
\texttt{samtools\ faidx}---for faster processing.
If a reference genome is not available, the \texttt{create\_genome} function creates
a reference genome of given equilibrium nucleotide distributions.
Sequence lengths are drawn from a gamma distribution
(Li et al., 2011)
with a mean and standard deviation provided by the user.

The access provided by the R class \texttt{ref\_genome} is designed to both
maximize flexibility and minimize copying and the chances of
printing extremely large strings to the console.
Methods in \texttt{ref\_genome} allow the user to view the
number of sequences, sequence sizes, sequence names, individual sequence strings,
and nucleotide proportions (GC or otherwise).
Users can also edit sequence names, remove one or more sequences by name,
and add sequences manually.
Method \texttt{filter\_sequences} filters genomes by the minimum sequence size or
by the smallest sequence that retains a given proportion of total reference
sequence if sequences are sorted by descending size.
Using method \texttt{merge\_sequences}, users can shuffle reference sequences and
merge them into one.
Method \texttt{replace\_Ns} replaces any \texttt{N}s in the reference sequence with nucleotides
that are sampled with weights proportional to their equilibrium distributions
(provided by the user).
Reference genomes can be written to FASTA files using the \texttt{write\_fasta} function.

\hypertarget{creating-variants}{%
\subsubsection{Creating variants}\label{creating-variants}}

Haploid variants from the reference genome are generated using the
\texttt{create\_variants} function.
To organize a potentially large amount of information that can be input to this function,
I added helper functions that handle parts of the input.
There are helper functions for the higher-level method information
(information from phylogenies, coalescent simulations, etc.) and
for various aspects of the molecular evolution (substitutions, indels, and among-site
variability in mutation rates).
The first subsection below outlines the higher-level information functions, and
the second subsection details the molecular evolution functions.

\hypertarget{higher-level-method-information}{%
\paragraph{Higher-level method information}\label{higher-level-method-information}}

There are five ways to generate variants from the reference genome, and
each has a function associated with it.
The names of these functions follow the form \texttt{vars\_X} for method \texttt{X},
and information on all of the function can be found in the \texttt{vars\_functions} documentation.
The outputs of these functions are meant to be passed to the \texttt{vars\_info} argument
in \texttt{create\_variants}.

The first two methods directly specify numbers and locations of mutations and
therefore do not require any phylogenomic methods in \texttt{jackalope}.
First, a variant call format (VCF) file can directly specify mutations for each
variant (function \texttt{vars\_vcf}).
This method works using the \texttt{vcfR} package
(Knaus \& Grünwald, 2017) and
is the only method that does not require any molecular-evolution information.
Second, matrices of segregating sites from coalescent output can provide the locations
of mutations (function \texttt{vars\_ssites}).
Molecular evolution information passed to \texttt{create\_variants} then informs the sampling
for the type of mutation at each site.
The segregating-site information can take the form of
(1) a coalescent-simulator object from the \texttt{scrm}
(Staab, Zhu, Metzler, \& Lunter, 2015) or
\texttt{coala} (Staab \& Metzler, 2016) package, or
(2) a file containing output from a coalescent simulator in the format of the
\texttt{ms} (Hudson, 2002) or
\texttt{msms} (Ewing \& Hermisson, 2010) programs.

The last three methods simulate sequences along phylogenies.
In the first of these methods,
phylogenetic tree(s) can be directly input from either \texttt{phylo} object(s) or
NEWICK file(s) (function \texttt{vars\_phylo}).
One tree can be used for all genome sequences, or each sequence can use a separate tree.
In the second method, users can pass an estimate for \(\theta\), the population-scaled
mutation rate (function \texttt{vars\_theta}).
A random coalescent tree is first generated using the \texttt{rcoal} function
in the \texttt{ape} package (Paradis \& Schliep, 2018).
Then, its total tree length is scaled to be
\(\theta / \mu \sum_{i=1}^{n-1}{1 / i}\) for \(n\) variants and an equilibrium
mutation rate of \(\mu\).
The last method allows for simulation of recombination by simulating along
gene trees that can differ both within and among reference sequences
(function \texttt{vars\_gtrees}).
Similarly to simulations using coalescent segregating sites, gene trees can be
from \texttt{scrm} or \texttt{coala} objects, or from \texttt{ms}-style output files.

For the phylogenomic methods, variants are simulated along tree branches by
generating exponential wait times
for the Markov ``jump'' chain for each sequence,
where the rate of the exponential distribution is the sum of mutation rates for
all nucleotides in the sequence (Yang, 2006).
At each jump, a position on the sequence is sampled with a probability proportional to
the mutation rate for that position.
A position's mutation rate is the product of its ``gamma distance''
(determined by among-site variability in mutation rates) and the overall mutation rate
for the nucleotide at that position
(determined by the summed indel and substitution rates).
After sampling a position, a mutation type is sampled with probabilities
proportional to the rate of each mutation type for the nucleotide
present at the sampled position.
Jumps are performed until the summed length of all jumps is greater than the
branch length.

Because sampling of mutation positions incorporates both among-site and among-nucleotide
variability in mutation rates,
users can separately specify rate variation that occurs due to
(1) where the nucleotides are positioned on the sequence molecule and
(2) the chemical structures of the nucleotides themselves.
To accomplish this, \texttt{jackalope} first splits each sequence into
smaller regions, where each region contains the same gamma distance.
The nucleotide-level rates are then summed by region and multiplied by the region's
gamma distance to get the region's overall rate.
I used these total rates as weights to sample regions, and
I incorporated a binary search tree to speed this sampling.
Simple inversion sampling is used to sample within a region.

Mutation-type sampling is performed by creating 4 vectors (one for each nucleotide),
each containing all possible mutation types:
substitutions to other nucleotides and insertions/deletions of all specified lengths.
I then use alias sampling
(Kronmal \& Peterson, 1979; Walker, 1974)
to sample within this vector.

\hypertarget{molecular-evolution}{%
\paragraph{Molecular evolution}\label{molecular-evolution}}

Molecular evolution information is provided to the \texttt{create\_variants}
function through organizing functions that are specific to the type of information:
substitutions, indels (insertions and deletions),
and variation in mutation rates among sites.
Substitutions use the \texttt{sub\_models} group of functions,
indels use the \texttt{indels} function,
and among-site variation uses the \texttt{site\_var} function.
A table of rates from
Sung et al. (2016)
is included in the package
as a guide for reasonable rates to use.

Each substitution model uses its own function of the pattern \texttt{sub\_M} for model \texttt{M},
and the provided \texttt{sub\_models} documentation includes information to help
users choose among them.
The following substitution models can be employed:
TN93 (Tamura \& Nei, 1993),
JC69 (Jukes \& Cantor, 1969),
K80 (Kimura, 1980),
F81 (Felsenstein, 1981),
HKY85 (Hasegawa, Kishino, \& Yano, 1985; Hasegawa, Yano, \& Kishino, 1984),
F84 (Thorne, Kishino, \& Felsenstein, 1992),
GTR (Tavar\a'e, 1986),
and UNREST (Yang, 1994).
If using the UNREST model, equilibrium nucleotide frequencies (\(\mathbf{\pi}\)) are
calculated by solving for \(\mathbf{\pi} \mathbf{Q} = 0\), where \(\mathbf{Q}\) is the
substitution rate matrix.
This is done by finding the left eigenvector of \(\mathbf{Q}\) that
corresponds to the eigenvalue closest to zero.

Providing insertion and deletion information is organized in the \texttt{indels} function.
It first requires an overall rate parameter, which is for the sum among all
nucleotides; indel rates do not differ among nucleotides.
The \texttt{indels} function also requires information about the relative rates of
indels of different sizes, which can be provided in 3 different ways.
First, rates can be proportional to \(\exp(-u)\) for indel length \(u\) from
1 to the maximum possible length, \(M\)
(Albers et al., 2010).
Second, rates can be generated from a Lavalette distribution,
where the rate for length \(u\) is proportional to
\(\left[{u M / (M - u + 1)}\right]^{-a}\)
(Fletcher \& Yang, 2009).
Third, relative rates can be specified directly by providing a length-\(M\)
numeric vector of positive values.
Indels up to 1 Mb are allowed.

Among-site variation in mutation rates, specified in the \texttt{site\_var} function,
is included either by generating gamma distances from a distribution
or by passing them manually.
Gamma distances are generated from a Gamma distribution with a fixed mean of 1
and with a shape parameter provided by the user;
a proportion of these regions can optionally be invariant.
Users can also pass a list of matrices, one for each reference sequence,
with a gamma distance and end point for each sequence region.
The gamma distances can optionally be written to a BED file.

\hypertarget{the-variants-class}{%
\subsubsection{\texorpdfstring{The \texttt{variants} class}{The variants class}}\label{the-variants-class}}

Haploid variant information is stored in the \texttt{variants} class.
Similarly to \texttt{ref\_genome}, this R6 class wraps a pointer to a C++ object
that stores all the information, and it was designed to prevent copying of large
objects in memory.
The underlying C++ class does not store whole variant genomes, but
rather just their mutation information---this dramatically reduces memory usage.
Methods in \texttt{variants} allow the user to view the number of sequences/variants,
variant sequence sizes, sequence/variant names, and individual variant-sequence strings.
Users can also edit variant names, remove one or more variants by name,
add blank variants, duplicate existing variants,
and manually add mutations.
Variant information can be written to VCF files using the \texttt{write\_vcf} function,
where each variant can optionally be considered one of multiple haplotypes for
samples with ploidy levels \textgreater{} 1.
Alternatively, variant genomes can be written to separate FASTA files
using \texttt{write\_fasta}.

\hypertarget{simulate-sequencing-data}{%
\subsubsection{Simulate sequencing data}\label{simulate-sequencing-data}}

Both R6 classes \texttt{ref\_genome} and \texttt{variants} can be input to the sequencing functions
\texttt{illumina} and \texttt{pacbio}.
Sequences from which reads are derived are sampled with weights proportional to
their length.
If a \texttt{variants} object is provided, individual variants are sampled with equal
probabilities by default.
Alternatively, the user can specify sampling weights for each variant
to simulate the library containing differing amounts of DNA from each.
Both methods also allow for a probability of read duplication, which might occur
due to PCR in either method and from optical duplicates in Illumina sequencing.
\texttt{jackalope} can create reads using multiple threads by having a read ``pool'' for
each thread and having pools write to file only when they are full.
This reduces conflicts that occur when multiple threads attempt to write to disk
at the same time.
The size of a ``full'' pool can be adjusted, and larger sizes should increase both
speed and memory usage.
Reads are output to FASTQ files.

Function \texttt{illumina} simulates single, paired-ended, or mate-pair Illumina reads,
while \texttt{pacbio} simulates reads from the Pacific Biosciences (PacBio) platform.
Illumina read simulation is based on the \texttt{ART} program
(Huang, Li, Myers, \& Marth, 2011), and
PacBio read simulation is based on \texttt{SimLoRD}
(Stöcker, Köster, \& Rahmann, 2016).
Each was re-coded in C++ to more seemlessly integrate into \texttt{jackalope}.
Function inputs emulate the program they were based on.

\hypertarget{validation-and-performance}{%
\subsection{Validation and performance}\label{validation-and-performance}}

I validated \texttt{jackalope} by conducting a series of simulations for variant creation
and Illumina and PacBio sequencing.
Using known inputs, I compared predicted to observed values of outputs,
and \texttt{jackalope} conformed closely to expectations
(Supporting Information Figures S1--S12).

I compared the performance of \texttt{jackalope} to existing programs on a MacBook
Pro running macOS Mojave (version 10.14.4) with a 2.6GHz Intel Core i5 processor
and 8 GB RAM.
Elapsed time and maximum memory used were measured by using the GNU \texttt{time} program
(\texttt{/usr/bin/time} from the terminal).
For each test, 10 runs of each program were tested in random order.

\hypertarget{creating-variants-1}{%
\subsubsection{Creating variants}\label{creating-variants-1}}

For creating variants, I compared \texttt{jackalope} to \texttt{Seq-Gen}
(Rambaut \& Grass, 1997).
I chose \texttt{Seq-Gen} because it is used by \texttt{TreeToReads} and because it can generate
sequences based on gene trees.
I tested each program by having them simulate a 2 Mb, 20 Mb, and 200 Mb genome
split evenly among 20 sequences, then generate 8 variants from that genome using
gene trees produced by the following \texttt{scrm} command:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{scrm}\NormalTok{ 8 20 -T -seed 1829812441 253160851 137767610 }\OperatorTok{>}\NormalTok{ scrm.tree}
\end{Highlighting}
\end{Shaded}

I used the HKY85 substitution model
with an overall mutation rate of 0.001 substitutions per site per unit of time
(where one unit of time is equal to a branch length of 1).
I did not include indels because \texttt{Seq-Gen} cannot simulate them.
Among-site variability was generated using a Gamma distribution with a shape
parameter of 1; in \texttt{jackalope}, the region size was 100 bp.
Output was written to either PHYLIP format (for \texttt{Seq-Gen}) or
FASTA files (for \texttt{jackalope}).
\texttt{jackalope} was tested for 1 and 4 threads, but
\texttt{Seq-Gen} for only 1 because it cannot use multiple threads.

\texttt{jackalope} consistently outperforms \texttt{Seq-Gen} in terms of speed, and the effect
of using 4 threads is most pronounced at the larger genome sizes
(Figure \ref{fig:variants-perf-test-plot}).
This makes sense, since the overhead associated with multithreading becomes more
worthwhile when there are more tasks to accomplish.
Memory usage is greater in \texttt{jackalope} at low genome sizes due to the overhead
associated with loading R:
An R script that simply printed an empty string used \(\sim 55\) MB memory,
and another that only loaded \texttt{jackalope} used \(\sim 70\) MB.
At the 20 Mb genome size, however, \texttt{jackalope} used slightly less memory than \texttt{Seq-Gen},
and for a 200 Mb genome size, \texttt{jackalope} used 38 \% less memory.

\hypertarget{generating-sequencing-reads}{%
\subsubsection{Generating sequencing reads}\label{generating-sequencing-reads}}

For both Illumina and PacBio read generation in \texttt{jackalope}, I tested their performance
in comparison to the programs they were based on:
\texttt{ART} (Huang et al., 2011) and
\texttt{SimLoRD} (Stöcker et al., 2016), respectively.
All these tests consisted of reading a 2 Mb genome from a FASTA file, simulating
reads, and writing them to FASTQ files.
For Illumina sequencing, these were \(2 \times 150\) reads from the HiSeq 2500 platform,
and tests were conducted for 100 thousand, 1 million, and 10 million total reads.
For PacBio sequencing, these were reads generated using default parameters,
and tests were conducted for 1, 10, and 100 thousand total reads.
\texttt{jackalope} was tested for 1 and 4 threads, but
neither \texttt{ART} nor \texttt{SimLoRD} allowed the use of more than 1.

Again, \texttt{jackalope} outperformed both \texttt{ART} and \texttt{SimLoRD} in terms of speed
(Figure \ref{fig:sequencing-perf-test-plot}).
Using multiple threads was most useful when many reads were generated:
For at least 10M Illumina reads and at least 1M PacBio reads, using 4 threads
reduced the time taken for jobs by \(\sim\) 50 \%.
All three programs used very little memory, and the amount did not depend strongly
on the number of reads generated.
\texttt{ART} used 9.4 MB and \texttt{SimLoRD} used 54.0--61.2 MB.
\texttt{jackalope} used 76.5--79.4 MB for Illumina reads and 101.3--110.1 MB for PacBio reads.

\hypertarget{example-usage}{%
\subsection{Example usage}\label{example-usage}}

This section provides brief examples of how \texttt{jackalope} can be used
to generate sequencing data that can inform some common sampling decisions for HTS
studies.
These examples only show how to produce the output from \texttt{jackalope}, as
a review of different pipelines is beyond the scope of the present manuscript.

For an example reference assembly, I used the \emph{Drosophila melanogaster} assembly
(version 6.27) downloaded from \texttt{flybase.org} (Thurmond et al., 2018).
After downloading, I read the compressed FASTA file, filtered out
scaffolds by using a size threshold, and manually removed the sex chromosomes
using the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ref <-}\StringTok{ }\KeywordTok{read_fasta}\NormalTok{(}\StringTok{"dmel-6.27.fasta.gz"}\NormalTok{, }\DataTypeTok{cut_names =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{ref}\OperatorTok{$}\KeywordTok{filter_seqs}\NormalTok{(}\FloatTok{1e6}\NormalTok{, }\DataTypeTok{method =} \StringTok{"size"}\NormalTok{)}
\NormalTok{ref}\OperatorTok{$}\KeywordTok{rm_seqs}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"X"}\NormalTok{, }\StringTok{"Y"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

This resulted in the following \texttt{ref\_genome} object:

\begin{verbatim}
## < Set of 5 sequences >
## # Total size: 110,338,337 bp
##   name                          sequence                             length
## 3R         ACGGGACCGAGTATAGTACCAGTAC...CGTGACTGTTCGCATTCTAGGAATTC  32079331
## 3L         TAGGGAGAAATATGATCGCGTATGC...TTCTATGTTATTCCATGTTATTCTAT  28110227
## 2R         CTCAAGATACCTTCTACAGATTATT...TGGAGGTACGGAAACAGAATGAATTC  25286936
## 2L         CGACAATGCACGACAGAGGAAGCAG...AACAGAGAACAGAGAACAGAGAAGAG  23513712
## 4          TTATTATATTATTATATTATTATAT...GCAGCCGTCGATTTGAGATATATGAA   1348131
\end{verbatim}

For molecular-evolution information, I used the TN93 model,
an insertion rate of \texttt{2e-5} for lengths from 1 to 10,
and
a deletion rate of \texttt{1e-5} for lengths from 1 to 40.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sub <-}\StringTok{ }\KeywordTok{sub_TN93}\NormalTok{(}\DataTypeTok{pi_tcag =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.4}\NormalTok{),}
                \DataTypeTok{alpha_1 =} \FloatTok{0.0001}\NormalTok{, }\DataTypeTok{alpha_2 =} \FloatTok{0.0002}\NormalTok{,}
                \DataTypeTok{beta =} \FloatTok{0.00015}\NormalTok{)}
\NormalTok{ins <-}\StringTok{ }\KeywordTok{indels}\NormalTok{(}\DataTypeTok{rate =} \FloatTok{2e-5}\NormalTok{, }\DataTypeTok{max_length =} \DecValTok{10}\NormalTok{)}
\NormalTok{del <-}\StringTok{ }\KeywordTok{indels}\NormalTok{(}\DataTypeTok{rate =} \FloatTok{1e-5}\NormalTok{, }\DataTypeTok{max_length =} \DecValTok{40}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{assembling-a-genome}{%
\subsubsection{Assembling a genome}\label{assembling-a-genome}}

The example here produces FASTQ files from the known reference assembly that could
test strategies for how to assemble a similar genome using HTS data.

The first strategy is to use only PacBio sequencing.
The PacBio Sequel system produces up to 500,000 reads per
Single Molecule, Real-Time (SMRT) cell, so you could
run the following for two cells:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pacbio}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"pacbio"}\NormalTok{, }\DataTypeTok{n_reads =} \DecValTok{2} \OperatorTok{*}\StringTok{ }\FloatTok{500e3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

An alternative, hybrid strategy uses
1 SMRT cell of PacBio sequencing and
1 lane (\(\sim 500\) million reads) of \(2 \times 100\)bp Illumina
sequencing on the HiSeq 2500 system (the default Illumina system in \texttt{jackalope}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pacbio}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"pacbio"}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{500e3}\NormalTok{)}
\KeywordTok{illumina}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"illumina"}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{500e6}\NormalTok{, }\DataTypeTok{paired =} \OtherTok{TRUE}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The last strategy combines 1 lane of \(2 \times 100\)bp Illumina HiSeq 2500 sequencing
with 1 flow cell of \(2 \times 250\)bp mate-pair sequencing on an Illumina MiSeq v3.
The mate-pair sequencing uses longer fragments (defaults are mean of 400 and
standard deviation of 100) to better cover highly
repetitive regions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{illumina}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"ill_pe"}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{500e6}\NormalTok{, }\DataTypeTok{paired =} \OtherTok{TRUE}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{100}\NormalTok{)}
\KeywordTok{illumina}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"ill_mp"}\NormalTok{, }\DataTypeTok{seq_sys =} \StringTok{"MSv3"}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{250}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{50e6}\NormalTok{, }\DataTypeTok{matepair =} \OtherTok{TRUE}\NormalTok{, }
         \DataTypeTok{frag_mean =} \DecValTok{3000}\NormalTok{, }\DataTypeTok{frag_sd =} \DecValTok{500}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{estimating-divergence-between-populations}{%
\subsubsection{Estimating divergence between populations}\label{estimating-divergence-between-populations}}

Here, I will demonstrate how to generate population-genomic data of a type that might
be used to estimate the divergence between two populations.
I first use the \texttt{scrm} package (Staab et al., 2015)
to conduct
coalescent simulations that will generate segregating sites for 40 haploid variants
from the reference genome.
Twenty of the variants are from one population, twenty from another.
The symmetrical migration rate is 100 individuals per generation.
To generate many mutations, I set the population-scaled mutation rate
(\(\theta = 4 N_0 \mu\)) to \texttt{1000} for this example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ssites <-}\StringTok{ }\KeywordTok{scrm}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"40"}\NormalTok{, ref}\OperatorTok{$}\KeywordTok{n_seqs}\NormalTok{(), }\StringTok{"-t 1000 -I 2 20 20 100"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Using the previously created objects for molecular evolution information (\texttt{sub},
\texttt{ins}, and \texttt{del}), I create variants from the reference genome:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vars <-}\StringTok{ }\KeywordTok{create_variants}\NormalTok{(ref, }\KeywordTok{vars_ssites}\NormalTok{(ssites), sub, ins, del)}
\end{Highlighting}
\end{Shaded}

This results in the following set of variants:

\begin{verbatim}
##                            << Variants object >>
## # Variants: 40
## # Mutations: 440,203
## 
##                         << Reference genome info: >>
## < Set of 5 sequences >
## # Total size: 110,338,337 bp
##   name                          sequence                             length
## 3R         ACGGGACCGAGTATAGTACCAGTAC...CGTGACTGTTCGCATTCTAGGAATTC  32079331
## 3L         TAGGGAGAAATATGATCGCGTATGC...TTCTATGTTATTCCATGTTATTCTAT  28110227
## 2R         CTCAAGATACCTTCTACAGATTATT...TGGAGGTACGGAAACAGAATGAATTC  25286936
## 2L         CGACAATGCACGACAGAGGAAGCAG...AACAGAGAACAGAGAACAGAGAAGAG  23513712
## 4          TTATTATATTATTATATTATTATAT...GCAGCCGTCGATTTGAGATATATGAA   1348131
\end{verbatim}

For a file of true divergences from the reference genome, the \texttt{write\_vcf} function
writes the \texttt{variants} object to a VCF file:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write_vcf}\NormalTok{(vars, }\StringTok{"variants"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Lastly, I simulate 1 lane of \(2 \times 100\)bp Illumina HiSeq 2500 sequencing.
In this case, individuals within a population are pooled, and the population
sequences are derived from are identified by barcodes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{illumina}\NormalTok{(vars, }\DataTypeTok{out_prefix =} \StringTok{"vars_illumina"}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{500e6}\NormalTok{, }\DataTypeTok{paired =} \OtherTok{TRUE}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{100}\NormalTok{, }\DataTypeTok{barcodes =} \KeywordTok{c}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"AACCGCGG"}\NormalTok{, }\DecValTok{20}\NormalTok{), }
                                         \KeywordTok{rep}\NormalTok{(}\StringTok{"GGTTATAA"}\NormalTok{, }\DecValTok{20}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

The below example instead has each individual variant's reads output to separate
FASTQ files:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{illumina}\NormalTok{(vars, }\DataTypeTok{out_prefix =} \StringTok{"vars_illumina"}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{500e6}\NormalTok{, }\DataTypeTok{paired =} \OtherTok{TRUE}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{100}\NormalTok{, }\DataTypeTok{sep_files =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{constructing-a-phylogeny}{%
\subsubsection{Constructing a phylogeny}\label{constructing-a-phylogeny}}

\hypertarget{from-one-phylogenetic-tree}{%
\paragraph{From one phylogenetic tree}\label{from-one-phylogenetic-tree}}

This section shows how \texttt{jackalope} can generate variants from a phylogeny, then
simulate sequencing data from those variants to test phylogeny reconstruction methods.
First, I generated a random coalescent tree of 10 species using the \texttt{ape} package
\texttt{citep(citation("ape"))}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tree <-}\StringTok{ }\NormalTok{ape}\OperatorTok{::}\KeywordTok{rcoal}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then I input that to the \texttt{create\_variants} function alongside the molecular evolution
information.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vars <-}\StringTok{ }\KeywordTok{create_variants}\NormalTok{(ref, }\KeywordTok{vars_phylo}\NormalTok{(tree), sub, ins, del)}
\end{Highlighting}
\end{Shaded}

This results in the following \texttt{variants} object:

\begin{verbatim}
##                            << Variants object >>
## # Variants: 10
## # Mutations: 301,710
## 
##                         << Reference genome info: >>
## < Set of 5 sequences >
## # Total size: 110,338,337 bp
##   name                          sequence                             length
## 3R         ACGGGACCGAGTATAGTACCAGTAC...CGTGACTGTTCGCATTCTAGGAATTC  32079331
## 3L         TAGGGAGAAATATGATCGCGTATGC...TTCTATGTTATTCCATGTTATTCTAT  28110227
## 2R         CTCAAGATACCTTCTACAGATTATT...TGGAGGTACGGAAACAGAATGAATTC  25286936
## 2L         CGACAATGCACGACAGAGGAAGCAG...AACAGAGAACAGAGAACAGAGAAGAG  23513712
## 4          TTATTATATTATTATATTATTATAT...GCAGCCGTCGATTTGAGATATATGAA   1348131
\end{verbatim}

Now I can generate data for 1 flow cell of \(2 \times 250\)bp sequencing
on an Illumina MiSeq v3.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{illumina}\NormalTok{(vars, }\DataTypeTok{out_prefix =} \StringTok{"phylo_tree"}\NormalTok{, }\DataTypeTok{seq_sys =} \StringTok{"MSv3"}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{250}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{50e6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{from-gene-trees}{%
\paragraph{From gene trees}\label{from-gene-trees}}

Similar to the section above, the ultimate goal here is to test phylogeny
reconstruction methods.
The difference in this section is that instead of using a single, straightforward
phylogeny, I use multiple gene trees per sequence.
In the species used in these simulations, species 3 diverged from 1 and 2 at \(t = 1.0\),
where \(t\) indicates time into the past and is in units of \(4 N_0\) generations.
Species 1 and 2 diverged at \(t = 0.5\).
I assume a recombination rate of \(1 / (4 N_0)\) recombination events per sequence
per generation.
Because each sequence is a different length and the length is required for including
a recombination rate, I had to run \texttt{scrm} separately for each sequence.
There are 4 diploid individuals sampled per species.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Run scrm for one sequence size:}
\NormalTok{one_seq <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(size) \{}
\NormalTok{    sims <-}\StringTok{ }\KeywordTok{scrm}\NormalTok{(}
        \KeywordTok{paste}\NormalTok{(}\StringTok{"24 1"}\NormalTok{,}
              \CommentTok{# Output gene trees:}
              \StringTok{"-T"}\NormalTok{,}
              \CommentTok{# Recombination:}
              \StringTok{"-r 1"}\NormalTok{, size,}
              \CommentTok{# 3 species with no ongoing migration:}
              \StringTok{"-I 3"}\NormalTok{, }\KeywordTok{paste}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"8"}\NormalTok{, }\DecValTok{3}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{" "}\NormalTok{), }\StringTok{"0"}\NormalTok{,}
              \CommentTok{# Species 3 derived from 1 (and 2) at time 1.0:}
              \StringTok{"-ej 1.0 3 1"}\NormalTok{,}
              \CommentTok{# Species 2 derived from 1 at time 0.5:}
              \StringTok{"-ej 0.5 2 1"}
\NormalTok{        ))}
    \KeywordTok{return}\NormalTok{(sims}\OperatorTok{$}\NormalTok{trees[[}\DecValTok{1}\NormalTok{]])}
\NormalTok{\}}
\CommentTok{# For all sequences:}
\NormalTok{gtrees <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{trees =} \KeywordTok{lapply}\NormalTok{(ref}\OperatorTok{$}\KeywordTok{sizes}\NormalTok{(), one_seq))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vars <-}\StringTok{ }\KeywordTok{create_variants}\NormalTok{(ref, }\KeywordTok{vars_gtrees}\NormalTok{(gtrees), sub, ins, del)}
\end{Highlighting}
\end{Shaded}

This results in the following \texttt{variants} object:

\begin{verbatim}
##                            << Variants object >>
## # Variants: 24
## # Mutations: 613,142
## 
##                         << Reference genome info: >>
## < Set of 5 sequences >
## # Total size: 110,338,337 bp
##   name                          sequence                             length
## 3R         ACGGGACCGAGTATAGTACCAGTAC...CGTGACTGTTCGCATTCTAGGAATTC  32079331
## 3L         TAGGGAGAAATATGATCGCGTATGC...TTCTATGTTATTCCATGTTATTCTAT  28110227
## 2R         CTCAAGATACCTTCTACAGATTATT...TGGAGGTACGGAAACAGAATGAATTC  25286936
## 2L         CGACAATGCACGACAGAGGAAGCAG...AACAGAGAACAGAGAACAGAGAAGAG  23513712
## 4          TTATTATATTATTATATTATTATAT...GCAGCCGTCGATTTGAGATATATGAA   1348131
\end{verbatim}

To store mutation information by diploid sample, the \texttt{write\_vcf} function writes
the \texttt{variants} object to a VCF file.
It assigns haplotypes to diploid samples using a matrix for the
\texttt{sample\_matrix} argument, where each row represents the variants for a particular
sample.
Ploidy level is not limited by \texttt{jackalope}, so polyploidy is easily simulated
by having more columns in the matrix.
The matrix for this set of diploid samples might look something like this
(only showing the first 5 rows below):

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
## [4,]    7    8
## [5,]    9   10
##          ...
\end{verbatim}

Using the matrix above assigns variants 1 and 2 to sample 1, variants 3 and 4 to
sample 2, and so on.
If the matrix is named \texttt{samp\_mat}, we would use it to write the VCF file as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write_vcf}\NormalTok{(vars, }\DataTypeTok{out_prefix =} \StringTok{"var_gtrees"}\NormalTok{,}
          \DataTypeTok{sample_matrix =}\NormalTok{ samp_mat)}
\end{Highlighting}
\end{Shaded}

Now I can generate data for 1 flow cell of \(2 \times 250\)bp sequencing
on an Illumina MiSeq v3.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{illumina}\NormalTok{(ref, }\DataTypeTok{out_prefix =} \StringTok{"phylo_gtrees"}\NormalTok{, }\DataTypeTok{seq_sys =} \StringTok{"MSv3"}\NormalTok{,}
         \DataTypeTok{read_length =} \DecValTok{250}\NormalTok{, }\DataTypeTok{n_reads =} \FloatTok{50e6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{conclusion}{%
\subsection{Conclusion}\label{conclusion}}

\texttt{jackalope} outperforms popular stand-alone programs for phylogenomic and HTS
simulation and combines their functionalities into one cohesive package.
Although it does not provide the in-built power of full pipelines like \texttt{NGSphy},
simulations using \texttt{jackalope} are much simpler to implement.
Moreover, the flexibility of \texttt{jackalope} allows power users to manually
provide inputs in many instances where the in-built functionality may not suffice.
This package should inform research design for projects employing HTS,
particularly those focusing on population genomics or phylogenomics.
Output from \texttt{jackalope} will help develop more specific sequencing goals
in funding applications and estimate the power of a given sequencing design.
Furthermore, \texttt{jackalope} can be used to test bioinformatic pipelines under
assumptions of much more complex evolutionary histories than most current HTS
simulation platforms allow.

\hypertarget{references}{%
\section{References}\label{references}}

\setstretch{1}

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-Albers_2010}{}%
Albers, C. A., Lunter, G., MacArthur, D. G., McVean, G., Ouwehand, W. H., \& Durbin, R. (2010). Dindel: Accurate indel calls from short-read data. \emph{Genome Research}, \emph{21}(6), 961--973. doi: \href{https://doi.org/10.1101/gr.112326.110}{10.1101/gr.112326.110}

\leavevmode\hypertarget{ref-Chang_2019}{}%
Chang, W. (2019). \emph{R6: Encapsulated classes with reference semantics}. Retrieved from \url{https://CRAN.R-project.org/package=R6}

\leavevmode\hypertarget{ref-Eddelbuettel_2011}{}%
Eddelbuettel, D., \& François, R. (2011). Rcpp: Seamless R and C++ integration. \emph{Journal of Statistical Software}, \emph{40}(8), 1--18. doi: \href{https://doi.org/10.18637/jss.v040.i08}{10.18637/jss.v040.i08}

\leavevmode\hypertarget{ref-Escalona_2016}{}%
Escalona, M., Rocha, S., \& Posada, D. (2016). A comparison of tools for the simulation of genomic next-generation sequencing data. \emph{Nature Reviews Genetics}, \emph{17}(8), 459--469. doi: \href{https://doi.org/10.1038/nrg.2016.57}{10.1038/nrg.2016.57}

\leavevmode\hypertarget{ref-Escalona_2018}{}%
Escalona, M., Rocha, S., \& Posada, D. (2018). NGSphy: Phylogenomic simulation of next-generation sequencing data. \emph{Bioinformatics}, \emph{34}(14), 2506--2507. doi: \href{https://doi.org/10.1093/bioinformatics/bty146}{10.1093/bioinformatics/bty146}

\leavevmode\hypertarget{ref-Ewing_2010}{}%
Ewing, G., \& Hermisson, J. (2010). MSMS: A coalescent simulation program including recombination, demographic structure and selection at a single locus. \emph{Bioinformatics}, \emph{26}(16), 2064--2065. doi: \href{https://doi.org/10.1093/bioinformatics/btq322}{10.1093/bioinformatics/btq322}

\leavevmode\hypertarget{ref-Felsenstein_1981}{}%
Felsenstein, J. (1981). Evolutionary trees from DNA sequences: A maximum likelihood approach. \emph{Journal of Molecular Evolution}, \emph{17}(6), 368--376. doi: \href{https://doi.org/10.1007/bf01734359}{10.1007/bf01734359}

\leavevmode\hypertarget{ref-Fletcher_2009}{}%
Fletcher, W., \& Yang, Z. (2009). INDELible: A flexible simulator of biological sequence evolution. \emph{Molecular Biology and Evolution}, \emph{26}(8), 1879--1888. doi: \href{https://doi.org/10.1093/molbev/msp098}{10.1093/molbev/msp098}

\leavevmode\hypertarget{ref-Forner_2018}{}%
Forner, K. (2018). \emph{RcppProgress: An interruptible progress bar with openmp support for c++ in r packages}. Retrieved from \url{https://CRAN.R-project.org/package=RcppProgress}

\leavevmode\hypertarget{ref-Hasegawa_1985}{}%
Hasegawa, M., Kishino, H., \& Yano, T.-a. (1985). Dating of the human-ape splitting by a molecular clock of mitochondrial DNA. \emph{Journal of Molecular Evolution}, \emph{22}(2), 160--174. doi: \href{https://doi.org/10.1007/bf02101694}{10.1007/bf02101694}

\leavevmode\hypertarget{ref-Hasegawa_1984}{}%
Hasegawa, M., Yano, T.-a., \& Kishino, H. (1984). A new molecular clock of mitochondrial DNA and the evolution of hominoids. \emph{Proceedings of the Japan Academy, Series B}, \emph{60}(4), 95--98. doi: \href{https://doi.org/10.2183/pjab.60.95}{10.2183/pjab.60.95}

\leavevmode\hypertarget{ref-Hayden_2019}{}%
Hayden, N., \& Morgan, M. (2019). \emph{Rhtslib: HTSlib high-throughput sequencing library as an r package}.

\leavevmode\hypertarget{ref-Huang_2011}{}%
Huang, W., Li, L., Myers, J. R., \& Marth, G. T. (2011). ART: A next-generation sequencing read simulator. \emph{Bioinformatics}, \emph{28}(4), 593--594. doi: \href{https://doi.org/10.1093/bioinformatics/btr708}{10.1093/bioinformatics/btr708}

\leavevmode\hypertarget{ref-Hudson_2002}{}%
Hudson, R. R. (2002). Generating samples under a wright-fisher neutral model of genetic variation. \emph{Bioinformatics}, \emph{18}(2), 337--338. doi: \href{https://doi.org/10.1093/bioinformatics/18.2.337}{10.1093/bioinformatics/18.2.337}

\leavevmode\hypertarget{ref-JC69}{}%
Jukes, T. H., \& Cantor, C. R. (1969). Evolution of protein molecules. In H. N. Munro (Ed.), \emph{Mammalian protein metabolism} (Vol. 3, pp. 21--131). New York: Academic Press.

\leavevmode\hypertarget{ref-Kimura_1980}{}%
Kimura, M. (1980). A simple method for estimating evolutionary rates of base substitutions through comparative studies of nucleotide sequences. \emph{Journal of Molecular Evolution}, \emph{16}(2), 111--120. doi: \href{https://doi.org/10.1007/bf01731581}{10.1007/bf01731581}

\leavevmode\hypertarget{ref-Knaus_2017}{}%
Knaus, B. J., \& Grünwald, N. J. (2017). VCFR: A package to manipulate and visualize variant call format data in R. \emph{Molecular Ecology Resources}, \emph{17}(1), 44--53.

\leavevmode\hypertarget{ref-Kronmal_1979}{}%
Kronmal, R. A., \& Peterson, A. V. (1979). On the alias method for generating random variables from a discrete distribution. \emph{The American Statistician}, \emph{33}(4), 214--218. doi: \href{https://doi.org/10.1080/00031305.1979.10482697}{10.1080/00031305.1979.10482697}

\leavevmode\hypertarget{ref-Li_2009}{}%
Li, H., Handsaker, B., Wysoker, A., Fennell, T., Ruan, J., Homer, N., \ldots{} and, R. D. (2009). The sequence alignment/map format and SAMtools. \emph{Bioinformatics}, \emph{25}(16), 2078--2079. doi: \href{https://doi.org/10.1093/bioinformatics/btp352}{10.1093/bioinformatics/btp352}

\leavevmode\hypertarget{ref-Li_2011}{}%
Li, X., Zhu, C., Lin, Z., Wu, Y., Zhang, D., Bai, G., \ldots{} Yu, J. (2011). Chromosome size in diploid eukaryotic species centers on the average length with a conserved boundary. \emph{Molecular Biology and Evolution}, \emph{28}(6), 1901--1911. doi: \href{https://doi.org/10.1093/molbev/msr011}{10.1093/molbev/msr011}

\leavevmode\hypertarget{ref-McTavish_2017}{}%
McTavish, E. J., Pettengill, J., Davis, S., Rand, H., Strain, E., Allard, M., \& Timme, R. E. (2017). TreeToReads - a pipeline for simulating raw reads from phylogenies. \emph{BMC Bioinformatics}, \emph{18}(1). doi: \href{https://doi.org/10.1186/s12859-017-1592-1}{10.1186/s12859-017-1592-1}

\leavevmode\hypertarget{ref-Metzker_2009}{}%
Metzker, M. L. (2009). Sequencing technologies the next generation. \emph{Nature Reviews Genetics}, \emph{11}(1), 31--46. doi: \href{https://doi.org/10.1038/nrg2626}{10.1038/nrg2626}

\leavevmode\hypertarget{ref-Morgan_2019}{}%
Morgan, M. (2019). \emph{Zlibbioc: An r packaged zlib-1.2.5}. Retrieved from \url{http://bioconductor.org/packages/release/bioc/html/Zlibbioc.html}

\leavevmode\hypertarget{ref-Oneill_2014pcg}{}%
O'Neill, M. E. (2014). \emph{PCG: a family of simple fast space-efficient statistically good algorithms for random number generation}. Claremont, CA: Harvey Mudd College.

\leavevmode\hypertarget{ref-Paradis_2018}{}%
Paradis, E., \& Schliep, K. (2018). Ape 5.0: An environment for modern phylogenetics and evolutionary analyses in R. \emph{Bioinformatics}, \emph{35}, 526--528.

\leavevmode\hypertarget{ref-Rambaut_1997}{}%
Rambaut, A., \& Grass, N. C. (1997). Seq-gen: An application for the monte carlo simulation of DNA sequence evolution along phylogenetic trees. \emph{Bioinformatics}, \emph{13}(3), 235--238. doi: \href{https://doi.org/10.1093/bioinformatics/13.3.235}{10.1093/bioinformatics/13.3.235}

\leavevmode\hypertarget{ref-R_Core_Team_2019}{}%
R Core Team. (2019). \emph{R: a language and environment for statistical computing}. Retrieved from \url{https://www.R-project.org/}

\leavevmode\hypertarget{ref-Paul_R._Staab_2016}{}%
Staab, P. R., \& Metzler, D. (2016). Coala: An R framework for coalescent simulation. \emph{Bioinformatics}. doi: \href{https://doi.org/10.1093/bioinformatics/btw098}{10.1093/bioinformatics/btw098}

\leavevmode\hypertarget{ref-Paul_R._Staab_2015}{}%
Staab, P. R., Zhu, S., Metzler, D., \& Lunter, G. (2015). scrm: Efficiently simulating long sequences using the approximated coalescent with recombination. \emph{Bioinformatics}, \emph{31}(10), 1680--1682.

\leavevmode\hypertarget{ref-St_cker_2016}{}%
Stöcker, B. K., Köster, J., \& Rahmann, S. (2016). SimLoRD: Simulation of long read data. \emph{Bioinformatics}, \emph{32}(17), 2704--2706. doi: \href{https://doi.org/10.1093/bioinformatics/btw286}{10.1093/bioinformatics/btw286}

\leavevmode\hypertarget{ref-Sung_2016}{}%
Sung, W., Ackerman, M. S., Dillon, M. M., Platt, T. G., Fuqua, C., Cooper, V. S., \& Lynch, M. (2016). Evolution of the insertion-deletion mutation rate across the tree of life. \emph{G3: Genes\(\vert\)Genomes\(\vert\)Genetics}, \emph{6}(8), 2583--2591. doi: \href{https://doi.org/10.1534/g3.116.030890}{10.1534/g3.116.030890}

\leavevmode\hypertarget{ref-TN93}{}%
Tamura, K., \& Nei, M. (1993). Estimation of the number of nucleotide substitutions in the control region of mitochondrial dna in humans and chimpanzees. \emph{Molecular Biology and Evolution}, \emph{10}(3), 512--526.

\leavevmode\hypertarget{ref-Tavare_1986gtr}{}%
Tavar\a'e, S. (1986). Some probabilistic and statistical problems in the analysis of DNA sequences. \emph{Lectures on Mathematics in the Life Sciences}, \emph{17}(2), 57--86.

\leavevmode\hypertarget{ref-Thorne_1992}{}%
Thorne, J. L., Kishino, H., \& Felsenstein, J. (1992). Inching toward reality: an improved likelihood model of sequence evolution. \emph{Journal of Molecular Evolution}, \emph{34}(1), 3--16.

\leavevmode\hypertarget{ref-Thurmond_2018}{}%
Thurmond, J., Goodman, J. L., Strelets, V. B., Attrill, H., Gramates, L. S., Marygold, S. J., \ldots{} and, P. B. (2018). FlyBase 2.0: The next generation. \emph{Nucleic Acids Research}, \emph{47}(D1), D759--D765. doi: \href{https://doi.org/10.1093/nar/gky1003}{10.1093/nar/gky1003}

\leavevmode\hypertarget{ref-Walker_1974}{}%
Walker, A. (1974). New fast method for generating discrete random numbers with arbitrary frequency distributions. \emph{Electronics Letters}, \emph{10}(8), 127. doi: \href{https://doi.org/10.1049/el:19740097}{10.1049/el:19740097}

\leavevmode\hypertarget{ref-Yang_2006}{}%
Yang, Z. (2006). \emph{Computational molecular evolution}. doi: \href{https://doi.org/10.1093/acprof:oso/9780198567028.001.0001}{10.1093/acprof:oso/9780198567028.001.0001}

\leavevmode\hypertarget{ref-Yang_1994}{}%
Yang, Z. B. (1994). Estimating the pattern of nucleotide substitution. \emph{Journal of Molecular Evolution}, \emph{39}(1), 105--111.

\setstretch{2}

\hypertarget{data-accessibility}{%
\section{Data Accessibility}\label{data-accessibility}}

\texttt{jackalope} is open source, under the MIT license.
Its code is available on GitHub
(\url{https://github.com/lucasnell/jackalope}), and
the documentation can be found at \url{https://jackalope.lucasnell.com}.
The package will soon be submitted to CRAN.
The version used in this manuscript was 0.1.0.
Code for the example usage, validation, and performance is available on GitHub at
\url{https://github.com/lucasnell/jlp_ms}.

\hypertarget{author-contributions}{%
\section{Author Contributions}\label{author-contributions}}

L.A.N. conceived and designed the project, wrote the code, and wrote the manuscript.

\begin{figure}
\centering
\includegraphics{figs/Fig_1.pdf}
\caption{\label{fig:jackalope-overview-figure}Overview of primary \texttt{jackalope} functions, classes, inputs, and outputs. Circles \texttt{sub\_models} and \texttt{vars\_functions} refer to multiple functions; see text for details. \(\theta\) indicates the population-scaled mutation rate.}
\end{figure}

\begin{figure}
\centering
\includegraphics{_manuscript_files/figure-latex/variants-perf-test-plot-1.pdf}
\caption{\label{fig:variants-perf-test-plot}Performance comparison between \texttt{jackalope} and \texttt{Seq-Gen} in generating variants from a reference genome. Sub-panels indicate the size of the genome from which variants were generated. Superscripts in the y-axis labels indicate the number of threads used.}
\end{figure}

\begin{figure}
\centering
\includegraphics{_manuscript_files/figure-latex/sequencing-perf-test-plot-1.pdf}
\caption{\label{fig:sequencing-perf-test-plot}Performance comparison between \texttt{jackalope} and (A) \texttt{ART} in generating Illumina reads and (B) \texttt{SimLoRD} in generating PacBio reads. Sub-panels indicate the number of reads generated. Superscripts in the y-axis labels indicate the number of threads used.}
\end{figure}




\end{document}
